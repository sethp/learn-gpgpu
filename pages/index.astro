---
import { getEntry } from 'astro:content';

type GetEntryParams = Parameters<typeof getEntry>;
type Collection = GetEntryParams[0];
type Id = GetEntryParams[1];

async function getContents(c: Collection, f: Id) {
	const file = await getEntry(c, f);
	// there's a type-shaped puzzle box here to remove the `!`;
	// right now, `getContents` accepts anything that might be a "raw file",
	// and/or a collection/id pair that might not even exist.
	//
	// There Exists A Way to restrict the type signature to only allow raw file
	// collections / existing IDs within those collections, but I don't know the
	// typescript meta-language well enough to identify an effective approach.
	return file!.data.contents;
}

// TODO: doesn't css do multiplication now? could we just say `x = width * (num prior siblings) + padding * (num prior siblings)`? should we?
// lol sorta: https://stackoverflow.com/a/66262844 (just gotta pre-generate the identity mapping from `nth-child(n) -> --var: n` for all n we care about)
const vis = {
	init: 'v0',
	lanes: {
		width: 15,
		height: 15,
		padding: {
			x: 1,
			y: 1,
		},
	},
	// TODO why can't ts sniff this one out?
	cores: Array(4).fill({
		lanes: {
			count: 8,
		},
	}),
};

// const splits = [/\n# ENTRY.*\n/];
// const tcfContents = await getContents('talvos', 'fill_idx.tcf');

// const tcfChunks = tcfContents.split(splits[0]);

// nice to have

// TODO: monaco editor
// TODO: lsp integration w/ tree-sitter
---

<html>
	<head>
		<title>gpgpu playground</title>
		<script>
			import { LITTLE_ENDIAN } from '../lib/binding';
			import { Arena } from '../lib/binding/arena';
			import { Ptr } from '../lib/binding/ptr';
			import { BitSet } from '../lib/bitset';
			import { States, ExecutionUniverse } from '../lib/executionUniverse';
			import { Talvos$$Device, Talvos$$Module, Talvos$$Params } from '../lib/talvos';
			import type { MainModule } from '../wasm/talvos-wasm';
			import talvos from '../wasm/talvos-wasm';

			// cf: https://stackoverflow.com/questions/14656893/css-stylesheet-scoped-to-a-single-svg-tag/62932376#62932376
			// and: https://stackoverflow.com/a/54869164/151464 (for why we're doing everything in a callback)
			class ShadowRootElement extends HTMLElement {
				constructor() {
					super();

					this._p = new Promise((resolve, _) => {
						this._resolve = resolve;
					});
				}
				get connected(): Promise<void> {
					return this._p;
				}
				connectedCallback() {
					const shadowRoot = this.attachShadow({
						mode: 'open',
						...this.attributes,
					});
					shadowRoot.append(...this.childNodes);
					this._resolve();
				}

				_p: Promise<void>;
				_resolve!: () => void;
			}
			customElements.define('shadow-root', ShadowRootElement);

			const rootEl = document.getElementById('talvos')!;

			const stdioEl =
				rootEl.querySelector<HTMLOutputElement>('output.stdio') || ({} as { value: HTMLOutputElement['value'] });
			const errorEl =
				rootEl.querySelector<HTMLOutputElement>('output.error') || ({} as { value: HTMLOutputElement['value'] });

			var Module = {
				print: function (text: any) {
					stdioEl.value += text + '\n';
				},
				printErr: function (text: any) {
					stdioEl.value += text + '\n';
				},
			} as any; /* TODO: emscripten types */

			window.addEventListener('error', (event) => {
				errorEl.value = '' + event.message;
			});
			window.addEventListener('unhandledrejection', function (event) {
				errorEl.value = '' + event.reason;
			});

			const svgEl = new Promise<SVGElement>(async (resolve, reject) => {
				// TODO we can do better, but...
				const roots = document.querySelectorAll<ShadowRootElement>('#talvos shadow-root');
				await Promise.all([...roots].map((el) => el.connected));

				for (const el of roots) {
					const tgt = el.shadowRoot!.querySelector<SVGElement>('svg.vis0');
					if (tgt) {
						resolve(tgt);
						return;
					}
				}
				reject('el not found');
			});
			// this part is................. well, it's a prototype
			const [doUpdateVis, clearVis] = (() => {
				// via https://matyasfodor.com/blog/efficient-zip#how-javascript-could-do-it
				// and https://stackoverflow.com/a/70192772/151464
				function* zip<T extends Iterable<unknown>[]>(
					...args: T
				): Generator<{ [K in keyof T]: T[K] extends Iterable<infer V> ? V : never }> {
					const iterators = args.map((iterable) => iterable[Symbol.iterator]());
					// TODO[seth]: this feels a little over-allocate-y? do we need a whole array just for the states?
					// TODO[seth]: maybe some benchmarks?
					let iterStates = iterators.map((iterator) => iterator.next());
					while (iterStates.every(({ done }) => !done)) {
						// @ts-expect-error
						yield iterStates.map(({ value }) => value);
						iterStates = iterators.map((iterator) => iterator.next());
					}
				}

				const clearVis = async () => {
					(await svgEl).querySelectorAll<SVGElement>('.lane').forEach((el) => {
						el.classList.remove('disabled', 'selected');
						el.dataset.state = 'inactive';
						delete el.dataset.logCoords;
					});
				};

				const layerViolationStopEl = document.querySelector<HTMLButtonElement>('#talvos button.stop')!;
				layerViolationStopEl.addEventListener('click', clearVis);
				const layerViolationContEl = document.querySelector<HTMLButtonElement>('#talvos button.continue')!;
				layerViolationContEl.addEventListener('click', () => setTimeout(clearVis, 0)); // lol
				const layerViolationRunEl = document.querySelector<HTMLButtonElement>('#talvos button.run')!;
				layerViolationRunEl.addEventListener('click', clearVis);

				function toDOMString(s: States) {
					switch (s) {
						case States.Active:
							return 'active';
						case States.Inactive:
							return 'inactive';
						case States.AtBarrier:
							return 'at-barrier';
						case States.AtBreakpoint:
							return 'at-breakpoint';
						case States.AtAssert:
							return 'at-assert';
						case States.AtException:
							return 'at-exception';
						case States.NotLaunched:
							return 'not-launched';
						case States.Exited:
							return 'exited';
						case States.UNKNOWN:
							return 'unkown';
					}
				}

				async function updateHardwareBlocks(e: ExecutionUniverse) {
					// last 2 `g`s (there is something weird here...)
					// svgEl.querySelectorAll('g:nth-last-child(-n+3) > rect').forEach((el) => el.classList.add('disabled'));

					console.assert('' + e.Cores == (await svgEl).dataset.cores);
					console.assert('' + e.Lanes == (await svgEl).dataset.lanes);

					for (const [idx, el, data] of zip(
						(function* () {
							let i = 0;
							while (true) {
								yield i++;
							}
						})(),
						(await svgEl).querySelectorAll<SVGElement>('g > .lane'),
						e.LaneStates
					)) {
						console.assert(`{ ${data.PhyCoord.Core}, ${data.PhyCoord.Lane} }` == el.dataset.phyCoords);

						el.dataset.state = toDOMString(data.State);
						el.dataset.logCoords = `{ 0, (${data.LogCoord.X},${data.LogCoord.Y},${data.LogCoord.Z}) }`;
						el.classList.toggle('selected', e.SteppedLanes.has(idx));
					}
				}

				return [
					async (e: ExecutionUniverse) => {
						let errs: any[] = [];
						// Let the updates fail independently
						// TODO: should module, device, & memory be part of the execution universe? or not?
						for (const f of [updateHardwareBlocks]) {
							try {
								f(e);
							} catch (e) {
								errs.push(e as any);
							}
						}

						if (errs.length > 0) throw errs;
					},
					clearVis,
				];
			})();

			const buffersEl = document.querySelector<HTMLElement>('#talvos section.buffers')!;
			// TODO source this from inside Talvos' model
			// TODO uninit memory
			var lastBuffers: any = {};
			function updateBuffers(Dev: Talvos$$Device, Mod: Talvos$$Module) {
				buffersEl.innerHTML = '';
				const Mem = Dev.GlobalMemory;
				const Objs = Dev.PipelineExecutor.Objects;

				for (const buf of Mod.Buffers) {
					const figEl = document.createElement('figure');
					const captionEl = document.createElement('figcaption');
					captionEl.innerText = `Buffer '${buf.Name.deref()?.asString() ?? '<unnamed>'}' (${buf.Size} bytes):'`;
					figEl.appendChild(captionEl);

					const listEl = document.createElement('ol');

					const addr = Objs.get(buf.Id).Data.data.getBigUint64(0, LITTLE_ENDIAN);
					const ptr = Mem.deref(addr, 64);

					// TODO: make this real
					const size = 4;
					const fn = (offset: number) => ptr.data.getUint32(offset, LITTLE_ENDIAN);

					const last = lastBuffers['0x' + addr.toString(16)] ?? [];
					var cur = [];
					for (var i = 0; i <= 15; i++) {
						const liEl = document.createElement('li');
						liEl.innerText = cur[i] = '' + fn(i * size);
						if (i in last && last[i] != cur[i]) liEl.dataset.prev = last[i]!;

						listEl.appendChild(liEl);
					}
					lastBuffers['0x' + addr.toString(16)] = cur;
					figEl.appendChild(listEl);

					buffersEl.appendChild(figEl);
				}
				// let ptr = Mem.deref(0x2_0000_0000_0000n, 64);
				// let ptr = Mem.deref(0x2000000000000n, 64);
				// console.log(ptr, ptr.data.getUint32(0, true));

				// for (auto &B : session.CF.Module->getBuffers())
				// {
				// 	uint64_t Addr = Dev.PipelineExecutor()
				// 											.getObject(B.Id)
				// 											.get<uint64_t>();
				// 	dump(Mem, Addr, B);
				// }
			}

			const selectEl = document.querySelector<HTMLSelectElement>('#talvos .controls select')!;
			selectEl.addEventListener('input', () => {
				switch (selectEl.value) {
					case 'v0':
					case 'v1':
						document.querySelectorAll(`#talvos > .vis.${selectEl.value}`).forEach((el) => {
							el.classList.remove('hidden');
						});
						document.querySelectorAll(`#talvos > .vis:not(.${selectEl.value})`).forEach((el) => {
							el.classList.add('hidden');
						});
						const wip = selectEl.value == 'v1';
						document.querySelector('#talvos')!.classList.toggle('vis-wip', wip);
						break;
					default:
						throw new Error(`unknown vis: ${selectEl.value}`);
				}
			});

			// What are we doing here? We're pulling the Promise<MainModule> inside out, so we can _synchronously_
			// install handlers that then individually (a)wait for the module to be loaded/instantiated.
			//
			// i.e. the difference between
			// ```
			// var foo = await module();
			// element.onclick = foo.func;
			// ```
			// and
			// ```
			// var foo = module();
			// element.onclick = async function () { (await foo).func() }
			// ```
			//
			// is that the former will prevent the handler from begin installed until the module is loaded,
			// meaning there's a window where clicking the button will do nothing.
			const [validate_wasm, exception, assertion, getExceptionMessage, { /*run, debug,*/ Session }] = (function (
				p: Promise<MainModule>
			) {
				return [
					p.then((instance) => instance.cwrap('validate_wasm', 'boolean', ['string'])),
					p.then((instance) => instance.cwrap('exception', undefined, [])),
					p.then((instance) => instance.cwrap('assertion', undefined, [])),
					p.then((instance) => instance.getExceptionMessage),
					(() => {
						var pp = p.then(
							({
								wasmExports: {
									Session__create__,
									Session__destroy__,
									Session__params_ref,
									Session__module_ref,
									Session__device_ref,

									Session_run,
									Session_dumpBuffers,
									Session_start,
									Session_step,
									Session_switch,
									Session_print,
									Session_continue,
									Session_printContext,

									Session_fetch_shrubbery,
								},

								stackAlloc,
								stackSave,
								stackRestore,
								stringToUTF8OnStack,
								// stringToUTF8Array,
								// UTF8ArrayToString,
								// writeArrayToMemory, // this is only HEAP8?
								HEAP32,
								// HEAP8,

								wasmMemory,
								_malloc,
								_free,

								// ...instance
							}) => {
								type dtor = () => void;
								function heapAlloc(size: number): [Ptr, dtor] {
									const addr = _malloc(size);
									const buf = wasmMemory.buffer;
									const ptr = new Ptr(buf, addr, size);
									return [ptr, () => _free(ptr.addr) as void];
								}

								function toCArgs(args: string[]) {
									const cstrs = args.map(stringToUTF8OnStack) as number[];
									const argv = stackAlloc(cstrs.length);
									// writeArrayToMemory(cstrs, argv);
									// HEAP32.set(cstrs, argv);
									cstrs.forEach((s, i) => {
										HEAP32[(argv + i * 4) >> 2] = s;
									});

									return [cstrs.length, argv];
								}

								const arenaSize = 1 << 12; // TODO
								class Session {
									ptr: unknown;

									// TODO ahh but I turned off typescript's help with these this way...
									// these are initialized in Session.bind, which the constructor calls
									// cf. https://stackoverflow.com/a/72540067
									arena!: Arena;
									lastOp!: ExecutionUniverse;
									laneMask!: BitSet;
									params!: Talvos$$Params;
									module!: Talvos$$Module;
									device!: Talvos$$Device;

									static bind(ptr: unknown) {
										try {
											var self = Object.create(this.prototype);
											self.ptr = ptr;
											self.arena = new Arena(...heapAlloc(arenaSize));
											self.lastOp = new ExecutionUniverse(self.arena.alloc(ExecutionUniverse.SIZE));
											self.laneMask = new BitSet(undefined, { data: self.arena.alloc(8).data });

											self.params = new Talvos$$Params(
												new Ptr(wasmMemory.buffer, Session__params_ref(ptr), Talvos$$Params.SIZE)
											);
											self.module = new Talvos$$Module(
												new Ptr(wasmMemory.buffer, Session__module_ref(ptr), Talvos$$Module.SIZE)
											);
											self.device = new Talvos$$Device(
												new Ptr(wasmMemory.buffer, Session__device_ref(ptr), Talvos$$Device.SIZE)
											);
										} catch (ex) {
											Session__destroy__(ptr);
											if (self?.arena) destroy(self.arena);
											throw ex;
										}
										return self;
									}

									constructor(module: string) {
										// TODO why this dance? what does stack save/stack restore do?
										const stack = stackSave();
										const [arg0, arg1] = [module, 'EXEC'].map(stringToUTF8OnStack) as number[];
										const ref = Session__create__(arg0, arg1);
										// TODO wrap the restore in a finally ?
										stackRestore(stack);
										return Session.bind(ref);
									}

									run() {
										Session_run(this.ptr);
									}
									dumpBuffers() {
										Session_dumpBuffers(this.ptr);
									}
									start() {
										lastBuffers = {};
										Session_start(this.ptr, this.lastOp.ptr.asRef());
										doUpdateVis(this.lastOp);
										updateBuffers(this.device, this.module);
									}
									async step(): Promise<number> {
										this.laneMask.clear();
										(await svgEl).querySelectorAll('.lane').forEach((el, i) => {
											// TODO this assumes a linear indexing of lanes, but we've got per-core indexing in talvos
											if (el.classList.contains('selected')) this.laneMask.add(i);
										});
										var ret = Session_step(this.ptr, this.laneMask.asRef(), this.lastOp.asRef());
										doUpdateVis(this.lastOp);
										updateBuffers(this.device, this.module);
										if (ret > 0) {
											clearVis();
										}
										return ret;
									}
									switch(args: string[]) {
										// TODO why this dance? what does stack save/stack restore do?
										const stack = stackSave();
										Session_switch(this.ptr, ...toCArgs(['switch', ...args]));
										// TODO wrap the restore in a finally ?
										stackRestore(stack);
									}
									print(args: string[]) {
										// TODO why this dance? what does stack save/stack restore do?
										const stack = stackSave();
										Session_print(this.ptr, ...toCArgs(['print', ...args]));
										// TODO wrap the restore in a finally ?
										stackRestore(stack);
									}
									continue() {
										Session_continue(this.ptr, this.lastOp.ptr.asRef());
										doUpdateVis(this.lastOp);
									}
									printContext() {
										Session_printContext(this.ptr);
									}

									fetchShrubbery() {
										var ret = this.arena.alloc(8);
										Session_fetch_shrubbery(this.ptr, ret.asRef());
										return new BitSet(undefined, { data: ret.data });
									}

									['__destroy__']() {
										// TODO use a finalizer pool?
										console.log('Session.destroy...');
										Session__destroy__(this.ptr);
										this.ptr = 0;
										destroy(this.arena);
									}
								}

								return {
									Session,
									// run: function () {
									// 	return Session.bind(instance.ccall('run_wasm', undefined, ['string', 'string'], arguments));
									// },
									// debug: function () {
									// 	return Session.bind(instance.ccall('debug_wasm', undefined, ['string', 'string'], arguments));
									// },
								};
							}
						);

						return {
							Session: pp.then((val) => val.Session),
							// run: pp.then((val) => val.run),
							// debug: pp.then((val) => val.debug),
						};
					})(),
				];
			})(talvos(Module));
			type Session = Awaited<typeof Session>;

			// TODO this probably belongs in some prejs thing over in talvos-land
			// @ts-ignore
			function destroy(self) {
				self['__destroy__']();
			}

			// TODO refactor into `withTiming` / `withExec` ?
			function captureOutput(f: Function, start?: PerformanceMeasure) {
				stdioEl.value = '';
				errorEl.value = '';
				rootEl.querySelector<HTMLOutputElement>('output.timing')!.value = `...`;
				rootEl.querySelectorAll<HTMLButtonElement>('button.exec').forEach((el) => (el.disabled = true));
				start = start ?? window.performance.mark('talvos');
				return (async () => f())()
					.catch(async (ex) => {
						var message;
						// @ts-ignore TODO `Property 'Exception' does not exist on type 'typeof WebAssembly'.`
						// e.g. ?
						// declare namespace WebAssembly {
						// 	interface Exception {}
						// }
						if (ex instanceof WebAssembly.Exception) {
							var type;
							[type, message] = (await getExceptionMessage)(ex);
							message = message || `of type ${type}`;

							console.error(
								/* must be the only argument to symbolicate properly */
								ex.stack
								/* cf. https://crbug.com/1428532 */
							);

							// this no longer works after https://github.com/emscripten-core/emscripten/pull/21775
							//
							// plus, since we're not doing the save/restore dance properly,
							// it looks like this might not even be enough: https://github.com/emscripten-core/emscripten/issues/21606
							//
							// Module.decrementExceptionRefcount(ex);
						} else {
							console.error(`in ${start.name}:`, ex);
							message = '' + ex;
						}
						errorEl.value = message;
					})
					.finally(() => {
						const call = window.performance.measure(start.name, start.name);
						rootEl.querySelector<HTMLOutputElement>('output.timing')!.value = `done in ${call.duration}ms`;
						rootEl.querySelectorAll<HTMLButtonElement>('button.exec').forEach((el) => el.removeAttribute('disabled'));
						// console.log(`done! took ${call.duration}ms`);
						// console.log('output:\n', outBuf);
					});
			}

			rootEl.querySelector<HTMLButtonElement>('button.validate')!.onclick = async function () {
				const text = (rootEl.querySelector('.module') as { value: string } | null)!.value;

				const start = window.performance.mark('validate_wasm', { detail: { text } });
				const ok = await captureOutput(async () => (await validate_wasm)(text), start);
				rootEl.querySelector<HTMLOutputElement>('output.stdio')!.value += ok ? 'ok!' : 'not ok :(';
			};

			rootEl.querySelector<HTMLButtonElement>('button.assertion')!.onclick = async () => captureOutput(await assertion);
			rootEl.querySelector<HTMLButtonElement>('button.exception')!.onclick = async () => captureOutput(await exception);
			rootEl.querySelector<HTMLButtonElement>('button.shrubbery')!.onclick = async () => {
				const s = (await Session).bind(0xc0ffeecafe);
				try {
					const bs = s.fetchShrubbery();
					console.log(bs);
				} finally {
					destroy(s.arena);
				}
			};

			rootEl.querySelector<HTMLButtonElement>('button.run')!.onclick = async function () {
				const text = (rootEl.querySelector('.module') as { value: string } | null)!.value;

				const start = window.performance.mark('run_wasm', { detail: { text } });
				captureOutput(async () => {
					const session = new (await Session)(text);
					const entryEl = rootEl.querySelector<HTMLSelectElement>('select[name="entry"]')!;
					session.params.EntryName = entryEl.selectedOptions.item(0)?.value ?? 'main';
					try {
						session.run();
						session.dumpBuffers();
					} finally {
						destroy(session);
					}
					// TODO something goes very wrong when `BUFFER output 2 INT32 FILL 0` (memory access exception reporting failure) and then we try to `run` again
					//   ^ bjorks the whole tab
					// TODO (generally, handling "invalid memory access" better?)
					// 		loosely; I think this means throwing away the whole talvos instance and re-creating it?
				}, start);
			};

			rootEl.querySelector<HTMLButtonElement>('button.debug')!.onclick = async function () {
				stdioEl.value = '';
				errorEl.value = '';
				rootEl.querySelector<HTMLOutputElement>('output.timing')!.value = `...`;
				rootEl.querySelectorAll<HTMLButtonElement>('button.exec').forEach((el) => (el.disabled = true));
				const text = (rootEl.querySelector('.module') as { value: string } | null)!.value;

				const start = window.performance.mark('debug', { detail: { text } });
				const session = new (await Session)(text);
				// session.params.EntryName = 'vecadd';
				session.params.EntryName = entryEl.selectedOptions.item(0)?.value ?? 'main';

				const debugCtrl = rootEl.querySelector<HTMLElement>('.debugger')!;

				function finish() {
					debugCtrl.hidden = true;
					// remove references to 1) allow the session to be GC'd, and 2) safety of the dangling pointer
					debugCtrl.querySelectorAll<HTMLButtonElement>('button').forEach((el) => (el.onclick = null));
					rootEl.querySelectorAll<HTMLButtonElement>('button.exec').forEach((el) => el.removeAttribute('disabled'));

					destroy(session);

					const call = window.performance.measure(start.name, start.name);
					rootEl.querySelector<HTMLOutputElement>('output.timing')!.value = `done in ${call.duration}ms`;
				}

				try {
					session.start();

					session.printContext();
				} catch (e) {
					finish();
					throw e;
				}

				const FINISHED = 1; // TODO sync with talvos::PipelineExecutor::StepResult

				debugCtrl.querySelector<HTMLButtonElement>('button.step')!.onclick = async function () {
					stdioEl.value = '';
					errorEl.value = '';
					try {
						const last = await session.step();
						if (last == FINISHED) {
							finish();
						}

						session.printContext();
					} catch (e) {
						finish();
						throw e;
					}
				};
				debugCtrl.querySelector<HTMLButtonElement>('button.switch')!.onclick = function () {
					const input = prompt('Usage: switch: X [Y [Z]]', 'X [Y [Z]]'); // %15 is `void` in vecadd
					if (input == null) {
						return;
					}
					const args = input.split(/\s+/);
					session.switch(args);
				};
				debugCtrl.querySelector<HTMLButtonElement>('button.print')!.onclick = function () {
					const input = prompt('Usage: print: %<id>', '%15'); // %15 is `void` in vecadd
					if (input == null) {
						return;
					}
					const args = input.split(/\s+/);
					session.print(args);
				};

				debugCtrl.querySelector<HTMLButtonElement>('button.stop')!.onclick = finish;
				debugCtrl.querySelector<HTMLButtonElement>('button.continue')!.onclick = function () {
					stdioEl.value = '';
					errorEl.value = '';
					try {
						session.continue();
					} finally {
						// TODO breakpoints
						finish();
					}
				};

				debugCtrl.hidden = false;
			};

			const entryEl = rootEl.querySelector<HTMLSelectElement>('select[name="entry"]')!;
			setTimeout(async function updateEntrypoints() {
				// lol redirect
				const oldOut = stdioEl.value,
					oldErr = errorEl.value;
				stdioEl.value = '';
				errorEl.value = '';

				const text = (rootEl.querySelector('.module') as { value: string } | null)!.value;

				const s = new (await Session)(text);
				try {
					console.log([...s.module.EntryPoints].map((ep) => ep.Name.asString()));
					entryEl.innerHTML = [...s.module.EntryPoints].map((ep) => `<option>${ep.Name.asString()}</option>`).join('');
				} finally {
					destroy(s);
				}

				if (stdioEl.value) {
					console.log(stdioEl.value);
				}
				stdioEl.value = oldOut;
				if (errorEl.value) {
					console.error(errorEl.value);
				}
				errorEl.value = oldErr;
				// TODO polling? or onchange notifications?
				// setTimeout(updateEntrypoints, 2000);
			}, 0);
		</script>
		<link rel="stylesheet" type="text/css" media="all" href="/learn-gpgpu/styles/index.css" />
	</head>
	<body>
		<nav>
			<ul>
				<li><a href="/learn-gpgpu/docs">docs/</a></li>
			</ul>
		</nav>
		<div id="talvos" class:list={vis.init == 'v1' ? ['vis-wip'] : []}>
			<div>
				<main>
					<textarea
						class="module"
						autocorrect="off"
						autocomplete="off"
						autocapitalize="off"
						spellcheck="false"
						aria-label="SPIR-V module assembly (spv_text format)"
						wrap="off">{await getContents('talvos', 'fill_idx.spvasm')}</textarea
					>
				</main>
				<aside>
					<section hidden>
						<label
							>ENTRY
							<select name="entry"></select>
						</label>
						<hr />
					</section>
					<!-- <section>
						<textarea
							class="commands_todo_make_js_concatenate_all_the_commands inactive"
							autocorrect="off"
							autocomplete="off"
							autocapitalize="off"
							spellcheck="false"
							aria-label="Talvos commands (informational)"
							disabled
							wrap="off">{tcfChunks[0]}</textarea
						>
					</section> -->
					<output class="stdio" style="display: block; background-color: lightgray; white-space: pre;"></output>
					<hr />
					<section class="buffers">
						<!-- <figure>
							<figcaption>Buffer</figcaption>
							<ul></ul>
						</figure> -->

						<!-- <textarea
							class="commands"
							style="height: 434px"
							autocorrect="off"
							autocomplete="off"
							autocapitalize="off"
							spellcheck="false"
							aria-label="Talvos commands (tcf format)"
							wrap="off">{tcfChunks[1]}</textarea
						> -->
					</section>
				</aside>
			</div>

			<div class="controls">
				<select id="vis">
					<option value="v0" selected={vis.init == 'v0' ? '' : undefined}
						>v0: control blocks; executor state colors</option
					>
					<option value="v1" selected={vis.init == 'v1' ? '' : undefined}
						>v1 (wip): control "scrubber"; SSA results</option
					>
				</select>

				<button class="validate exec">validate</button>
				<button class="run exec">run</button>
				<button class="debug exec">debug</button>

				<div hidden>
					<button class="exception">exception</button>
					<button class="assertion">assertion</button>
					<button class="shrubbery">shrubbery</button>
				</div>

				<div class="debugger" hidden>
					<!-- cf. PipelineExecutor::help -->
					<button class="step">step</button>
					<button class="switch">switch</button>
					<button class="print">print</button>
					<button class="continue">continue</button>
					<button class="stop">stop</button>
					<!-- missing: [break, breakpoint, help, quit] -->
				</div>
			</div>

			<!-- TODO
				 can we pull out just this one wodget into a "component"?
				 it'd be nice to write some code for turning `102043253.21231222ms` into a human time
			-->
			<output class="timing" style="display: block;"></output>
			<output class="error" style="display: block; background-color: #fcebeb;"></output>

			<shadow-root class:list={['vis', 'v0', ...(vis.init == 'v0' ? [] : ['hidden'])]}>
				<svg
					xmlns="http://www.w3.org/2000/svg"
					class="vis0"
					data-cores={vis.cores.length}
					data-lanes={vis.cores[0].lanes.count}
				>
					<style>
						g.core :hover,
						g.core :focus {
							filter: drop-shadow(0 0 3px rgb(0 0 0 / 0.4));
						}

						g.core .ctrl {
							fill: chocolate;
						}

						.lane.selected,
						.ctrl:has(~ .lane.selected):not(:has(~ .lane:not(.selected))) {
							filter: url(#inset-shadow);
						}

						.ctrl:has(~ .lane[data-state='not-launched']):not(:has(~ .lane[data-state='not-launched'])) {
							filter: opacity(60%);
						}

						/* .disabled {
						filter: opacity(60%);
					} */

						/*
						TODO these colors are from NVIDIA nsight; but they're also bad?

						cf. "CUDA Debugger Warp Info View" from https://developer.nvidia.com/nsight-visual-studio-edition
						(https://d29g4g2dyqv443.cloudfront.net/sites/default/files/akamai/tools/nsvse/nsvse2020_1/NsVSE_Dbg_WarpInfo_Vw.png)
					*/
						/* TODO: wait, what's `not-launched` vs `inactive`? */
						.lane[data-state='active'] {
							fill: forestgreen;
						}
						.lane[data-state='inactive'] {
							fill: grey;
						}

						.lane[data-state='at-barrier'] {
							fill: lightseagreen;
						}
						.lane[data-state='at-breakpoint'] {
							fill: red;
						}
						.lane[data-state='at-assert'] {
							fill: orange;
						}
						.lane[data-state='at-exception'] {
							fill: darkred;
						}
						.lane[data-state='not-launched'] {
							fill: darkgray;
						}
						.lane[data-state='exited'] {
							fill: lightgray;
						}

						/* svg text {
						visibility: hidden;
					}
					svg:hover text {
						visibility: visible;
					} */

						/*
						NB: doesn't work for two reasons: css-for-svg doesn't support the `content` property or the `::before` pseudo-element

						cf. https://svgwg.org/svg2-draft/styling.html#RequiredProperties
						and https://svgwg.org/svg2-draft/styling.html#RequiredCSSFeatures
					*/
						/* tspan.physical::before {
						content: 'hello';
					} */

						/* lol there's also CSS-only way to do the hover text, if we don't mind the nth-child(n) -> --var:n mapping thing above */
						/* we'd have to break out using `foreignObject`, though */
					</style>

					<!-- <script></script> -->
					<!-- <defs>
					<pattern id="tenthGrid" width="10" height="10" patternUnits="userSpaceOnUse">
						<path d="M 10 0 L 0 0 0 10" fill="none" stroke="silver" stroke-width="0.5"></path>
					</pattern>
					<pattern id="grid" width="100" height="100" patternUnits="userSpaceOnUse">
						<rect width="100" height="100" fill="url(#tenthGrid)"></rect>
						<path d="M 100 0 L 0 0 0 100" fill="none" stroke="gray" stroke-width="1"></path>
					</pattern>
				</defs>
				<rect width="100%" height="100%" fill="url(#grid)"></rect> -->

					<defs>
						<filter id="inset-shadow">
							<!-- lol hates it -->
							<!-- <link
							href="https://css-tricks.com/adding-shadows-to-svg-icons-with-css-and-svg-filters/#aa-using-svg-filters"
							rel="help"
						/> -->
							<!-- Shadow offset -->
							<feOffset dx="0" dy="0"></feOffset>

							<!-- Shadow blur -->
							<feGaussianBlur stdDeviation="6" result="offset-blur"></feGaussianBlur>

							<!-- Invert drop shadow to make an inset shadow -->
							<feComposite operator="out" in="SourceGraphic" in2="offset-blur" result="inverse"></feComposite>

							<!-- Cut color inside shadow -->
							<feFlood flood-color="black" flood-opacity=".95" result="color"></feFlood>
							<feComposite operator="in" in="color" in2="inverse" result="shadow"></feComposite>

							<!-- Placing shadow over element -->
							<feComposite operator="over" in="shadow" in2="SourceGraphic"></feComposite>
						</filter>
					</defs>

					${
						vis.cores.map((core, i) => (
							<g class="core" transform={`translate(0, ${vis.lanes.height * i + vis.lanes.padding.y * i})`}>
								<rect class="ctrl" x={vis.lanes.width / 4} width={vis.lanes.width * 1.5} height={vis.lanes.height} />
								{Array.from({ length: core.lanes.count }).map((_, j) => (
									<rect
										x={(j + 2) * (vis.lanes.width + vis.lanes.padding.x)}
										width={vis.lanes.width}
										height={vis.lanes.height}
										data-phy-coords={`{ ${i}, ${j} }`}
										class="lane"
										data-state="inactive"
									/>
								))}
							</g>
						))
					}

					<!-- could put this above, if we knew how tall an em was (or translated negatively?) -->
					<text y={vis.cores.length * (vis.lanes.height + vis.lanes.padding.y) + vis.lanes.padding.y}>
						<tspan x="0" dy="1em">physical {`{core, SIMT lane}`}:</tspan>
						<tspan class="physical">N/A</tspan>
						<tspan x="0" dy="1.2em">logical {`{workgroup, invocation}`}:</tspan>
						<tspan class="logical">N/A</tspan>
					</text>
				</svg>
			</shadow-root>

			<shadow-root class:list={['vis', 'v1', ...(vis.init == 'v1' ? [] : ['hidden'])]}>
				<!-- TODO:
					a. "step 1/2" button (half a "cycle", to show frame #2?)
					b. some kind of "windowing" around the program, so we don't just try to generate an infinitely large thing?
					c. a11y: https://www.sitepoint.com/tips-accessible-svg/ & https://www.sarasoueidan.com/blog/structuring-grouping-referencing-in-svg/
				-->

				<style is:inline>
					svg {
						border: 2px solid #00f;
					}
				</style>
				<!-- see also: https://css-tricks.com/scale-svg/ -->
				<!-- frame #1 -->
				<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" height="240px">
					<style>
						.result {
							fill-opacity: 0;
							stroke: black;
							stroke-width: 1px;

							transform-box: fill-box;
							transform-origin: center;
							transform: rotate(45deg);
						}

						rect {
							fill-opacity: 0;
							stroke: black;
						}

						rect.result:not(.issued) {
							stroke: none;
							fill: none;
							/* stroke-dasharray: 1px 8px; */
						}

						rect.result.issued:not(.retired) {
							stroke-dasharray: 2px;
						}
					</style>

					<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 60 240" x="60" width="60px" height="240px">
						<style>
							rect.yummy {
								stroke: none;
								fill: chocolate;
								fill-opacity: 100%;
							}

							.vertical.centerline {
								stroke: none;
							}
						</style>
						<defs>
							<symbol id="handle" width="30" height="30" viewBox="0 0 25 30" preserveAspectRatio="none">
								<polygon points="5 0,25 0,25 20,15 30,5 20"></polygon>
							</symbol>

							<!-- <symbol id="result" width="80" height="80">
					<polygon points="0 40,40 80,80 40,40 0" style=" fill: blue; stroke:black;"></polygon>
				</symbol> -->
						</defs>

						<g class="core">
							<!-- <use href="#handle" style="fill-opacity: 0; stroke:black;" x="12"></use> -->
							<rect x="0" y="30" height="200" width="60"></rect>

							<!-- 40x30 at (10 40); centerline: 30 -->
							<rect x="10" y="40" height="30" width="40" class="yummy"></rect>
						</g>

						<line x1="30" y1="0" x2="30" y2="100%" stroke="grey" class="vertical centerline"></line>
					</svg>

					<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 60 240" x="0" width="60px" height="240px">
						<g class="op">
							<circle cx="30" cy="55" r="12" fill="white" stroke="black"></circle>
							<text x="30" y="55" dominant-baseline="middle" text-anchor="middle" style="font-size: smaller;">%2</text>
							<g>
								<rect width="20" height="20" x="20" y="80" class="result issued retired"></rect>
								<rect width="20" height="20" x="20" y="110" class="result issued retired"></rect>
								<rect width="20" height="20" x="20" y="140" class="result issued retired"></rect>
								<rect width="20" height="20" x="20" y="170" class="result issued retired"></rect>
							</g>
						</g>
					</svg>

					<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 60 240" x="60" width="60px" height="240px">
						<g class="op">
							<circle cx="30" cy="55" r="12" fill="white" stroke="black"></circle>
							<text x="30" y="55" dominant-baseline="middle" text-anchor="middle" style="font-size: smaller;">%3</text>

							<g>
								<rect width="20" height="20" x="20" y="80" class="result issued retired"></rect>
								<rect width="20" height="20" x="20" y="110" class="result issued"></rect>
								<rect width="20" height="20" x="20" y="140" class="result issued"></rect>
								<rect width="20" height="20" x="20" y="170" class="result issued"></rect>
							</g>
						</g>
					</svg>

					<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 60 240" x="120" width="60px" height="240px">
						<g class="op">
							<circle cx="30" cy="55" r="12" fill="white" stroke="black"></circle>
							<text x="30" y="55" dominant-baseline="middle" text-anchor="middle" style="font-size: smaller;">%4</text>
							<g>
								<rect width="20" height="20" x="20" y="80" class="result"></rect>
								<rect width="20" height="20" x="20" y="110" class="result"></rect>
								<rect width="20" height="20" x="20" y="140" class="result"></rect>
								<rect width="20" height="20" x="20" y="170" class="result"></rect>
							</g>
						</g>
					</svg>

					<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 60 240" x="180" width="60px" height="240px">
						<g class="op">
							<circle cx="30" cy="55" r="12" fill="white" stroke="black"></circle>
							<text x="30" y="55" dominant-baseline="middle" text-anchor="middle" style="font-size: smaller;">sd</text
							></g
						>
						<g>
							<rect width="20" height="20" x="20" y="80" class="result"></rect>
							<rect width="20" height="20" x="20" y="110" class="result"></rect>
							<rect width="20" height="20" x="20" y="140" class="result"></rect>
							<rect width="20" height="20" x="20" y="170" class="result"></rect>
						</g>
					</svg>
				</svg>

				<!-- frame #2 -->
				<!-- (frame #1 + 30px for "slider" position; marked all %3 results [ops?] as "retired") -->
				<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" height="240px">
					<style>
						.result {
							fill-opacity: 0;
							stroke: black;
							stroke-width: 1px;

							transform-box: fill-box;
							transform-origin: center;
							transform: rotate(45deg);
						}

						rect {
							fill-opacity: 0;
							stroke: black;
						}

						rect.result:not(.issued) {
							stroke: none;
							fill: none;
							/* stroke-dasharray: 1px 8px; */
						}

						rect.result.issued:not(.retired) {
							stroke-dasharray: 2px;
						}
					</style>

					<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 60 240" x="90" width="60px" height="240px">
						<style>
							rect.yummy {
								stroke: none;
								fill: chocolate;
								fill-opacity: 100%;
							}

							.vertical.centerline {
								stroke: none;
							}
						</style>
						<defs>
							<symbol id="handle" width="30" height="30" viewBox="0 0 25 30" preserveAspectRatio="none">
								<polygon points="5 0,25 0,25 20,15 30,5 20"></polygon>
							</symbol>

							<!-- <symbol id="result" width="80" height="80">
					<polygon points="0 40,40 80,80 40,40 0" style=" fill: blue; stroke:black;"></polygon>
				</symbol> -->
						</defs>

						<!-- <g class="core_newclass"> -->
						<!-- <use href="#handle" style="fill-opacity: 0; stroke:black;" x="12"></use> -->
						<rect x="0" y="30" height="200" width="60"></rect>

						<!-- 40x30 at (10 40); centerline: 30 -->
						<rect x="10" y="40" height="30" width="40" class="yummy"></rect>
						<!-- </g> -->

						<line x1="30" y1="0" x2="30" y2="100%" stroke="grey" class="vertical centerline"></line>
					</svg>

					<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 60 240" x="0" width="60px" height="240px">
						<g class="op">
							<circle cx="30" cy="55" r="12" fill="white" stroke="black"></circle>
							<text x="30" y="55" dominant-baseline="middle" text-anchor="middle" style="font-size: smaller;">%2</text>
							<g>
								<rect width="20" height="20" x="20" y="80" class="result issued retired"></rect>
								<rect width="20" height="20" x="20" y="110" class="result issued retired"></rect>
								<rect width="20" height="20" x="20" y="140" class="result issued retired"></rect>
								<rect width="20" height="20" x="20" y="170" class="result issued retired"></rect>
							</g>
						</g>
					</svg>

					<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 60 240" x="60" width="60px" height="240px">
						<g class="op">
							<circle cx="30" cy="55" r="12" fill="white" stroke="black"></circle>
							<text x="30" y="55" dominant-baseline="middle" text-anchor="middle" style="font-size: smaller;">%3</text>

							<g>
								<rect width="20" height="20" x="20" y="80" class="result issued retired"></rect>
								<rect width="20" height="20" x="20" y="110" class="result issued retired"></rect>
								<rect width="20" height="20" x="20" y="140" class="result issued retired"></rect>
								<rect width="20" height="20" x="20" y="170" class="result issued retired"></rect>
							</g>
						</g>
					</svg>

					<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 60 240" x="120" width="60px" height="240px">
						<g class="op">
							<circle cx="30" cy="55" r="12" fill="white" stroke="black"></circle>
							<text x="30" y="55" dominant-baseline="middle" text-anchor="middle" style="font-size: smaller;">%4</text>
							<g>
								<rect width="20" height="20" x="20" y="80" class="result"></rect>
								<rect width="20" height="20" x="20" y="110" class="result"></rect>
								<rect width="20" height="20" x="20" y="140" class="result"></rect>
								<rect width="20" height="20" x="20" y="170" class="result"></rect>
							</g>
						</g>
					</svg>

					<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 60 240" x="180" width="60px" height="240px">
						<g class="op">
							<circle cx="30" cy="55" r="12" fill="white" stroke="black"></circle>
							<text x="30" y="55" dominant-baseline="middle" text-anchor="middle" style="font-size: smaller;">sd</text
							></g
						>
						<g>
							<rect width="20" height="20" x="20" y="80" class="result"></rect>
							<rect width="20" height="20" x="20" y="110" class="result"></rect>
							<rect width="20" height="20" x="20" y="140" class="result"></rect>
							<rect width="20" height="20" x="20" y="170" class="result"></rect>
						</g>
					</svg>
				</svg>

				<!-- frame #3 -->
				<!-- (frame #2 + 30px for "slider" position; marked all %4 results [ops?] as "issued") -->
				<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" height="240px">
					<style>
						.result {
							fill-opacity: 0;
							stroke: black;
							stroke-width: 1px;

							transform-box: fill-box;
							transform-origin: center;
							transform: rotate(45deg);
						}

						rect {
							fill-opacity: 0;
							stroke: black;
						}

						rect.result:not(.issued) {
							stroke: none;
							fill: none;
							/* stroke-dasharray: 1px 8px; */
						}

						rect.result.issued:not(.retired) {
							stroke-dasharray: 2px;
						}
					</style>

					<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 60 240" x="120" width="60px" height="240px">
						<style>
							rect.yummy {
								stroke: none;
								fill: chocolate;
								fill-opacity: 100%;
							}

							.vertical.centerline {
								stroke: none;
							}
						</style>
						<defs>
							<symbol id="handle" width="30" height="30" viewBox="0 0 25 30" preserveAspectRatio="none">
								<polygon points="5 0,25 0,25 20,15 30,5 20"></polygon>
							</symbol>

							<!-- <symbol id="result" width="80" height="80">
					<polygon points="0 40,40 80,80 40,40 0" style=" fill: blue; stroke:black;"></polygon>
				</symbol> -->
						</defs>

						<!-- <g class="core_newclass"> -->
						<!-- <use href="#handle" style="fill-opacity: 0; stroke:black;" x="12"></use> -->
						<rect x="0" y="30" height="200" width="60"></rect>

						<!-- 40x30 at (10 40); centerline: 30 -->
						<rect x="10" y="40" height="30" width="40" class="yummy"></rect>
						<!-- </g> -->

						<line x1="30" y1="0" x2="30" y2="100%" stroke="grey" class="vertical centerline"></line>
					</svg>

					<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 60 240" x="0" width="60px" height="240px">
						<g class="op">
							<circle cx="30" cy="55" r="12" fill="white" stroke="black"></circle>
							<text x="30" y="55" dominant-baseline="middle" text-anchor="middle" style="font-size: smaller;">%2</text>
							<g>
								<rect width="20" height="20" x="20" y="80" class="result issued retired"></rect>
								<rect width="20" height="20" x="20" y="110" class="result issued retired"></rect>
								<rect width="20" height="20" x="20" y="140" class="result issued retired"></rect>
								<rect width="20" height="20" x="20" y="170" class="result issued retired"></rect>
							</g>
						</g>
					</svg>

					<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 60 240" x="60" width="60px" height="240px">
						<g class="op">
							<circle cx="30" cy="55" r="12" fill="white" stroke="black"></circle>
							<text x="30" y="55" dominant-baseline="middle" text-anchor="middle" style="font-size: smaller;">%3</text>

							<g>
								<rect width="20" height="20" x="20" y="80" class="result issued retired"></rect>
								<rect width="20" height="20" x="20" y="110" class="result issued retired"></rect>
								<rect width="20" height="20" x="20" y="140" class="result issued retired"></rect>
								<rect width="20" height="20" x="20" y="170" class="result issued retired"></rect>
							</g>
						</g>
					</svg>

					<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 60 240" x="120" width="60px" height="240px">
						<g class="op">
							<circle cx="30" cy="55" r="12" fill="white" stroke="black"></circle>
							<text x="30" y="55" dominant-baseline="middle" text-anchor="middle" style="font-size: smaller;">%4</text>
							<g>
								<rect width="20" height="20" x="20" y="80" class="result issued"></rect>
								<rect width="20" height="20" x="20" y="110" class="result issued"></rect>
								<rect width="20" height="20" x="20" y="140" class="result issued"></rect>
								<rect width="20" height="20" x="20" y="170" class="result issued"></rect>
							</g>
						</g>
					</svg>

					<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 60 240" x="180" width="60px" height="240px">
						<g class="op">
							<circle cx="30" cy="55" r="12" fill="white" stroke="black"></circle>
							<text x="30" y="55" dominant-baseline="middle" text-anchor="middle" style="font-size: smaller;">sd</text
							></g
						>
						<g>
							<rect width="20" height="20" x="20" y="80" class="result"></rect>
							<rect width="20" height="20" x="20" y="110" class="result"></rect>
							<rect width="20" height="20" x="20" y="140" class="result"></rect>
							<rect width="20" height="20" x="20" y="170" class="result"></rect>
						</g>
					</svg>
				</svg>
			</shadow-root>

			<div class="controls vis v1" class:list={[...(vis.init == 'v1' ? [] : ['hidden'])]}>
				<button class="reset exec">reset</button>
				<button class="vis step0 exec">step (vis)</button>
				<button class="vis step1 exec">step (line)</button>
			</div>
			<shadow-root class:list={['vis', 'v1', ...(vis.init == 'v1' ? [] : ['hidden'])]}>
				{
					// TODO: this gets hoisted up "above" the earlier scripts when built for `dist`
					//
					// this leads to a deadlock between the top-level await (on `customElements.whenDefined`),
					// and the `customElements.define` call, so instead we wrap the whole thing in its own little
					// immediately-invoked async context.
					//
					// see also: https://discord.com/channels/830184174198718474/1263201016212361329/1263201016212361329
				}
				<script>
					interface ShadowRootElement extends Element {
						get connected(): Promise<void>;
					}

					(async () => {
						const ops = ['%2', '%3', '%4', 'st'];
						var state: { cur: number; last: 'issued' | 'retired' | 'none' } = {
							cur: 1,
							last: 'issued',
						};

						const resetEl = document.querySelector('#talvos .controls button.reset')!;
						resetEl.addEventListener('click', function () {
							state = { cur: 1, last: 'issued' };
							drawModule();
						});
						const stepEl = document.querySelector('#talvos .controls button.vis.step0')!;
						stepEl.addEventListener('click', function () {
							state = {
								cur: state.cur + 1,
								last: 'issued',
							};
							drawModule();
						});

						const svgEl = await new Promise<SVGElement>(async (resolve, reject) => {
							// TODO we can do better, but...
							await customElements.whenDefined('shadow-root');
							const roots = document.querySelectorAll<ShadowRootElement>('#talvos shadow-root');
							for (const el of roots) {
								const tgt = el.shadowRoot!.querySelector<SVGElement>('svg.vis1');
								if (tgt) {
									resolve(tgt);
									return;
								}
							}
							reject('el not found');
						});

						// TODO[seth]: we shouldn't replace on every transition, just once at the beginning
						function drawModule() {
							svgEl.replaceChildren(
								...svgEl.querySelectorAll('style,defs'),
								((el: Node & SVGElement) => {
									el.setAttribute('href', '#step');
									el.setAttribute('width', '60px');
									el.setAttribute('height', '240px');
									el.setAttribute('x', `${(state.cur || 1) * 60}`); // TODO this works b/c clipping
									return el;
								})(document.createElementNS('http://www.w3.org/2000/svg', 'use')),

								...ops.map((op, idx) => {
									// <svg xmlns="http://www.w3.org/2000/svg" ... />
									const opSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
									opSvg.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns', 'http://www.w3.org/2000/svg');

									opSvg.setAttribute('viewBox', '0 0 60 240');
									opSvg.setAttribute('width', '60px');
									opSvg.setAttribute('height', '240px');
									opSvg.setAttribute('x', `${idx * 60}`);

									const opEl = opSvg.appendChild(document.createElementNS('http://www.w3.org/2000/svg', 'circle'));

									opEl.setAttribute('cx', '30');

									opEl.setAttribute('cy', '55');
									opEl.setAttribute('r', '12');

									const opLabelEl = opSvg.appendChild(document.createElementNS('http://www.w3.org/2000/svg', 'text'));

									// x="30" y="55" dominant-baseline="middle" text-anchor="middle"
									opLabelEl.setAttribute('x', '30');
									opLabelEl.setAttribute('y', '55');
									opLabelEl.setAttribute('dominant-baseline', 'middle');
									opLabelEl.setAttribute('text-anchor', 'middle');
									opLabelEl.append(op);

									const gEl = opSvg.appendChild(document.createElementNS('http://www.w3.org/2000/svg', 'g'));

									// <rect width="20" height="20" x="20" y="80 + ..." class="result issued retired"></rect>
									for (var i = 0; i < parseInt(svgEl.dataset.lanes || ''); i++) {
										const resEl = gEl.appendChild(document.createElementNS('http://www.w3.org/2000/svg', 'rect'));
										resEl.setAttribute('x', '20');
										resEl.setAttribute('y', `${80 + 30 * i}`);
										resEl.setAttribute('width', '20');
										resEl.setAttribute('height', '20');
										resEl.classList.add('result');
										if (idx < state.cur || (idx == state.cur && state.last == 'retired'))
											resEl.classList.add('retired');
										if (idx < state.cur || (idx == state.cur && state.last != 'none')) resEl.classList.add('issued');
									}

									return opSvg;
								})
							);
						}
						drawModule();
					})();
				</script>
				<svg
					xmlns="http://www.w3.org/2000/svg"
					viewBox="0 0 240 240"
					height="240px"
					class="vis1"
					data-cores="TODO"
					data-lanes="4"
				>
					<style>
						.result {
							fill-opacity: 0;
							stroke: black;
							stroke-width: 1px;

							transform-box: fill-box;
							transform-origin: center;
							transform: rotate(45deg);
						}

						circle {
							fill: white;
							stroke: black;
						}

						rect {
							fill-opacity: 0;
							stroke: black;
						}

						rect.result:not(.issued) {
							stroke: none;
							fill: none;
							/* stroke-dasharray: 1px 8px; */
						}

						rect.result.issued:not(.retired) {
							stroke-dasharray: 2px;
						}

						text {
							font-size: smaller;
						}
					</style>

					<defs>
						<svg id="step" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 60 240">
							<style>
								rect.core {
									stroke: none;
									fill: chocolate;
									fill-opacity: 100%;
								}

								.vertical.centerline {
									stroke: none;
								}
							</style>
							<defs>
								<symbol id="handle" width="30" height="30" viewBox="0 0 25 30" preserveAspectRatio="none">
									<polygon points="5 0,25 0,25 20,15 30,5 20"></polygon>
								</symbol>
							</defs>

							<!-- <use href="#handle" style="fill-opacity: 0; stroke:black;" x="12"></use> -->
							<rect x="0" y="30" height="200" width="60"></rect>

							<!-- 40x30 at (10 40); centerline: 30 -->
							<rect x="10" y="40" height="30" width="40" class="core"></rect>
						</svg>

						<line x1="30" y1="0" x2="30" y2="100%" stroke="grey" class="vertical centerline"></line>
					</defs>
				</svg>
			</shadow-root>
		</div>
	</body>
</html>

<script>
	const svgEl = document.querySelector<SVGElement>('#talvos svg.vis0')!;

	const phyEl = svgEl.querySelector<SVGTSpanElement>('tspan.physical')!;
	const logEl = svgEl.querySelector<SVGTSpanElement>('tspan.logical')!;

	const laneEls = svgEl.querySelectorAll<SVGElement>('.lane');
	for (const el of laneEls) {
		el.addEventListener('mouseenter', function () {
			phyEl.textContent = this.dataset.phyCoords!;
			logEl.textContent = this.dataset.logCoords ?? 'N/A';
		});
		el.addEventListener('mouseleave', function () {
			phyEl.textContent = 'N/A';
			logEl.textContent = 'N/A';
		});

		el.addEventListener('click', function () {
			if (this.classList.contains('.disabled')) return;

			this.classList.toggle('selected');
		});
	}

	const ctrlEls = svgEl.querySelectorAll<SVGElement>('.ctrl');
	for (const [i, el] of ctrlEls.entries()) {
		el.addEventListener('mouseenter', function () {
			// TODO don't assume lane width
			phyEl.textContent = `{ ${i}, [${i * 8}-${i * 8 + 7}] }`;
		});
		el.addEventListener('mouseleave', function () {
			phyEl.textContent = 'N/A';
		});

		el.addEventListener('click', function () {
			// TODO tease apart "the scheduler decided" vs "the human decided"
			const selectable = !!this.parentNode!.querySelector('.lane[data-state="active"], .lane[data-state="inactive"]');
			if (!selectable) return;

			const hasNoneSelected = !this.parentNode!.querySelector('.lane.selected');
			this.parentNode!.querySelectorAll<SVGElement>('.lane').forEach((laneEl) => {
				laneEl.classList.toggle('selected', hasNoneSelected);
			});
		});
	}
</script>
