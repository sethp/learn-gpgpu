---
import { getEntry } from 'astro:content';

type GetEntryParams = Parameters<typeof getEntry>;
type Collection = GetEntryParams[0];
type Id = GetEntryParams[1];

async function getContents(c: Collection, f: Id) {
	const file = await getEntry(c, f);
	// there's a type-shaped puzzle box here to remove the `!`;
	// right now, `getContents` accepts anything that might be a "raw file",
	// and/or a collection/id pair that might not even exist.
	//
	// There Exists A Way to restrict the type signature to only allow raw file
	// collections / existing IDs within those collections, but I don't know the
	// typescript meta-language well enough to identify an effective approach.
	return file!.data.contents;
}

// TODO: doesn't css do multiplication now? could we just say `x = width * (num prior siblings) + padding * (num prior siblings)`? should we?
// lol sorta: https://stackoverflow.com/a/66262844 (just gotta pre-generate the identity mapping from `nth-child(n) -> --var: n` for all n we care about)
const vis = {
	init: 'v1',
	lanes: {
		width: 15,
		height: 15,
		padding: {
			x: 1,
			y: 1,
		},
	},
	// TODO why can't ts sniff this one out?
	cores: Array(4).fill({
		lanes: {
			count: 8,
		},
	}),
};

// const splits = [/\n# ENTRY.*\n/];
// const tcfContents = await getContents('talvos', 'fill_idx.tcf');

// const tcfChunks = tcfContents.split(splits[0]);

// nice to have

// TODO: monaco editor
// TODO: lsp integration w/ tree-sitter
---

<html>
	<head>
		<meta charset="utf-8" />
		<title>gpgpu playground</title>
		<script>
			import { LITTLE_ENDIAN } from '../lib/binding';
			import { Arena } from '../lib/binding/arena';
			import { Ptr } from '../lib/binding/ptr';
			import { BitSet } from '../lib/bitset';
			import { States, ExecutionUniverse } from '../lib/executionUniverse';
			import { Talvos$$Core } from '../lib/talvos';
			import {
				Talvos$$Cores,
				Talvos$$Device,
				Talvos$$Dim3,
				Talvos$$Instruction,
				Talvos$$Module,
				Talvos$$Params,
			} from '../lib/talvos';
			import type { MainModule } from '../wasm/talvos-wasm';
			import talvos from '../wasm/talvos-wasm';

			// cf: https://stackoverflow.com/questions/14656893/css-stylesheet-scoped-to-a-single-svg-tag/62932376#62932376
			// and: https://stackoverflow.com/a/54869164/151464 (for why we're doing everything in a callback)
			class ShadowRootElement extends HTMLElement {
				constructor() {
					super();

					this._p = new Promise((resolve, _) => {
						this._resolve = resolve;
					});
				}
				get connected(): Promise<void> {
					return this._p;
				}
				connectedCallback() {
					const shadowRoot = this.attachShadow({
						mode: 'open',
						...this.attributes,
					});
					shadowRoot.append(...this.childNodes);
					this._resolve();
				}

				_p: Promise<void>;
				_resolve!: () => void;
			}
			customElements.define('shadow-root', ShadowRootElement);

			const rootEl = document.getElementById('talvos')!;

			const stdioEl = rootEl.querySelector<HTMLOutputElement>('output.stdio')!;
			const errorEl =
				rootEl.querySelector<HTMLOutputElement>('output.error') || ({} as { value: HTMLOutputElement['value'] });

			var Module = {
				print: function (text: any) {
					stdioEl.value += text + '\n';
				},
				printErr: function (text: any) {
					stdioEl.value += text + '\n';
					console.error(text);
				},
			} as any; /* TODO: emscripten types */

			window.addEventListener('error', (event) => {
				errorEl.value = '' + event.message;
			});
			window.addEventListener('unhandledrejection', function (event) {
				errorEl.value = '' + event.reason;
			});

			const svgEl = new Promise<SVGElement>(async (resolve, reject) => {
				// TODO we can do better, but...
				const roots = document.querySelectorAll<ShadowRootElement>('#talvos shadow-root');
				await Promise.all([...roots].map((el) => el.connected));

				for (const el of roots) {
					const tgt = el.shadowRoot!.querySelector<SVGElement>('svg.vis0');
					if (tgt) {
						resolve(tgt);
						return;
					}
				}
				reject('el not found');
			});
			// this part is................. well, it's a prototype
			const [doUpdateVis, clearVis] = (() => {
				// via https://matyasfodor.com/blog/efficient-zip#how-javascript-could-do-it
				// and https://stackoverflow.com/a/70192772/151464
				function* zip<T extends Iterable<unknown>[]>(
					...args: T
				): Generator<{ [K in keyof T]: T[K] extends Iterable<infer V> ? V : never }> {
					const iterators = args.map((iterable) => iterable[Symbol.iterator]());
					// TODO[seth]: this feels a little over-allocate-y? do we need a whole array just for the states?
					// TODO[seth]: maybe some benchmarks?
					let iterStates = iterators.map((iterator) => iterator.next());
					while (iterStates.every(({ done }) => !done)) {
						// @ts-expect-error
						yield iterStates.map(({ value }) => value);
						iterStates = iterators.map((iterator) => iterator.next());
					}
				}

				const clearVis = async () => {
					(await svgEl).querySelectorAll<SVGElement>('.lane').forEach((el) => {
						el.classList.remove('disabled', 'selected');
						el.dataset.state = 'inactive';
						delete el.dataset.logCoords;
					});
				};

				const layerViolationStopEl = document.querySelector<HTMLButtonElement>('#talvos button.stop')!;
				layerViolationStopEl.addEventListener('click', clearVis);
				const layerViolationContEl = document.querySelector<HTMLButtonElement>('#talvos button.continue')!;
				layerViolationContEl.addEventListener('click', () => setTimeout(clearVis, 0)); // lol
				const layerViolationRunEl = document.querySelector<HTMLButtonElement>('#talvos button.run')!;
				layerViolationRunEl.addEventListener('click', clearVis);

				function toDOMString(s: States) {
					switch (s) {
						case States.Active:
							return 'active';
						case States.Inactive:
							return 'inactive';
						case States.AtBarrier:
							return 'at-barrier';
						case States.AtBreakpoint:
							return 'at-breakpoint';
						case States.AtAssert:
							return 'at-assert';
						case States.AtException:
							return 'at-exception';
						case States.NotLaunched:
							return 'not-launched';
						case States.Exited:
							return 'exited';
						case States.UNKNOWN:
							return 'unkown';
					}
				}

				async function updateHardwareBlocks(e: ExecutionUniverse) {
					// last 2 `g`s (there is something weird here...)
					// svgEl.querySelectorAll('g:nth-last-child(-n+3) > rect').forEach((el) => el.classList.add('disabled'));

					console.assert('' + e.Cores == (await svgEl).dataset.cores);
					console.assert('' + e.Lanes == (await svgEl).dataset.lanes);

					for (const [idx, el, data] of zip(
						(function* () {
							let i = 0;
							while (true) {
								yield i++;
							}
						})(),
						(await svgEl).querySelectorAll<SVGElement>('g > .lane'),
						e.LaneStates
					)) {
						console.assert(`{ ${data.PhyCoord.Core}, ${data.PhyCoord.Lane} }` == el.dataset.phyCoords);

						el.dataset.state = toDOMString(data.State);
						el.dataset.logCoords = `{ 0, (${data.LogCoord.X},${data.LogCoord.Y},${data.LogCoord.Z}) }`;
						el.classList.toggle('selected', e.SteppedLanes.has(idx));
					}
				}

				return [
					async (e: ExecutionUniverse) => {
						let errs: any[] = [];
						// Let the updates fail independently
						// TODO: should module, device, & memory be part of the execution universe? or not?
						for (const f of [updateHardwareBlocks]) {
							try {
								f(e);
							} catch (e) {
								errs.push(e as any);
							}
						}

						if (errs.length > 0) throw errs;
					},
					clearVis,
				];
			})();

			const buffersEl = rootEl.querySelector<HTMLElement>('section.buffers')!;
			// TODO source this from inside Talvos' model
			var lastBuffers: any = {};
			// TODO uninit memory
			function updateBuffers(Dev: Talvos$$Device, Mod: Talvos$$Module) {
				buffersEl.innerHTML = '';
				const Mem = Dev.GlobalMemory;
				const Objs = Dev.PipelineExecutor.Objects;

				for (const buf of Mod.Buffers) {
					const figEl = document.createElement('figure');
					const captionEl = document.createElement('figcaption');
					captionEl.innerText = `Buffer '${buf.Name.deref()?.asString() ?? '<unnamed>'}' (${buf.Size} bytes):`;
					figEl.appendChild(captionEl);

					const listEl = document.createElement('ol');

					const addr = Objs.get(buf.Id).Data.data.getBigUint64(0, LITTLE_ENDIAN);
					const ptr = Mem.deref(addr, buf.Size);

					// TODO: make this real (read the type)
					const elemSize = 4;
					const fn = (offset: number) => ptr.data.getUint32(offset, LITTLE_ENDIAN);

					const last = lastBuffers['0x' + addr.toString(16)] ?? [];
					var cur = [];
					for (var i = 0; i < buf.Size / elemSize; i++) {
						const liEl = document.createElement('li');
						liEl.innerText = cur[i] = '' + fn(i * elemSize);
						if (i in last && last[i] != cur[i]) liEl.dataset.prev = last[i]!;

						listEl.appendChild(liEl);
					}
					lastBuffers['0x' + addr.toString(16)] = cur;
					figEl.appendChild(listEl);

					buffersEl.appendChild(figEl);
				}
				// let ptr = Mem.deref(0x2_0000_0000_0000n, 64);
				// let ptr = Mem.deref(0x2000000000000n, 64);
				// console.log(ptr, ptr.data.getUint32(0, true));

				// for (auto &B : session.CF.Module->getBuffers())
				// {
				// 	uint64_t Addr = Dev.PipelineExecutor()
				// 											.getObject(B.Id)
				// 											.get<uint64_t>();
				// 	dump(Mem, Addr, B);
				// }
			}

			const selectEl = document.querySelector<HTMLSelectElement>('#talvos .controls select')!;
			selectEl.addEventListener('input', () => {
				switch (selectEl.value) {
					case 'v0':
					case 'v1':
						document.querySelectorAll(`#talvos > .vis.${selectEl.value}`).forEach((el) => {
							el.classList.remove('hidden');
						});
						document.querySelectorAll(`#talvos > .vis:not(.${selectEl.value})`).forEach((el) => {
							el.classList.add('hidden');
						});
						const wip = selectEl.value == 'v1';
						document.querySelector('#talvos')!.classList.toggle('vis-wip', wip);
						break;
					default:
						throw new Error(`unknown vis: ${selectEl.value}`);
				}
			});

			// What are we doing here? We're pulling the Promise<MainModule> inside out, so we can _synchronously_
			// install handlers that then individually (a)wait for the module to be loaded/instantiated.
			//
			// i.e. the difference between
			// ```
			// var foo = await module();
			// element.onclick = foo.func;
			// ```
			// and
			// ```
			// var foo = module();
			// element.onclick = async function () { (await foo).func() }
			// ```
			//
			// is that the former will prevent the handler from begin installed until the module is loaded,
			// meaning there's a window where clicking the button will do nothing.
			const [validate_wasm, exception, assertion, getExceptionMessage, { /*run, debug,*/ Session }] = (function (
				p: Promise<MainModule>
			) {
				return [
					p.then((instance) => instance.cwrap('validate_wasm', 'boolean', ['string'])),
					p.then((instance) => instance.cwrap('exception', undefined, [])),
					p.then((instance) => instance.cwrap('assertion', undefined, [])),
					p.then((instance) => instance.getExceptionMessage),
					(() => {
						var pp = p.then(
							({
								wasmExports: {
									Session__create__,
									Session__destroy__,
									Session__params_ref,
									Session__module_ref,
									Session__device_ref,
									Session__cores_ref,

									Session_run,
									Session_dumpBuffers,
									Session_start,
									Session_step,
									Session_switch,
									Session_print,
									Session_continue,
									Session_tick,

									Session_getCurrentInsn,
									Session_printContext,
									Session_getCurrentId,

									Session_fetch_shrubbery,
								},

								stackAlloc,
								stackSave,
								stackRestore,
								stringToUTF8OnStack,
								// stringToUTF8Array,
								// UTF8ArrayToString,
								// writeArrayToMemory, // this is only HEAP8?
								HEAP32,
								// HEAP8,

								wasmMemory,
								_malloc,
								_free,

								// ...instance
							}) => {
								type dtor = () => void;
								function heapAlloc(size: number): [Ptr, dtor] {
									const addr = _malloc(size);
									const buf = wasmMemory.buffer;
									const ptr = new Ptr(buf, addr, size);
									return [ptr, () => _free(ptr.addr) as void];
								}

								function toCArgs(args: string[]) {
									const cstrs = args.map(stringToUTF8OnStack) as number[];
									const argv = stackAlloc(cstrs.length);
									// writeArrayToMemory(cstrs, argv);
									// HEAP32.set(cstrs, argv);
									cstrs.forEach((s, i) => {
										HEAP32[(argv + i * 4) >> 2] = s;
									});

									return [cstrs.length, argv];
								}

								const arenaSize = 1 << 12; // TODO
								class Session {
									ptr: unknown;

									// TODO ahh but I turned off typescript's help with these this way...
									// these are initialized in Session.bind, which the constructor calls
									// cf. https://stackoverflow.com/a/72540067
									arena!: Arena;
									lastOp!: ExecutionUniverse;
									laneMask!: BitSet;
									params!: Talvos$$Params;
									module!: Talvos$$Module;
									device!: Talvos$$Device;
									lastId!: Talvos$$Dim3;
									cores!: Talvos$$Cores;

									static bind(ptr: unknown) {
										try {
											var self = Object.create(this.prototype);
											self.ptr = ptr;
											self.arena = new Arena(...heapAlloc(arenaSize));
											self.lastOp = new ExecutionUniverse(self.arena.alloc(ExecutionUniverse.SIZE));
											self.laneMask = new BitSet(undefined, { data: self.arena.alloc(8).data });

											self.params = new Talvos$$Params(
												new Ptr(wasmMemory.buffer, Session__params_ref(ptr), Talvos$$Params.SIZE)
											);
											self.module = new Talvos$$Module(
												new Ptr(wasmMemory.buffer, Session__module_ref(ptr), Talvos$$Module.SIZE)
											);
											self.device = new Talvos$$Device(
												new Ptr(wasmMemory.buffer, Session__device_ref(ptr), Talvos$$Device.SIZE)
											);
											self.lastId = new Talvos$$Dim3(self.arena.alloc(Talvos$$Dim3.SIZE));

											self.cores = new Talvos$$Cores(
												new Ptr(wasmMemory.buffer, Session__cores_ref(ptr), Talvos$$Cores.SIZE)
											);
										} catch (ex) {
											Session__destroy__(ptr);
											if (self?.arena) destroy(self.arena);
											throw ex;
										}
										return self;
									}

									constructor(module: string) {
										// TODO why this dance? what does stack save/stack restore do?
										const stack = stackSave();
										const [arg0, arg1] = [module, 'EXEC'].map(stringToUTF8OnStack) as number[];
										const ref = Session__create__(arg0, arg1);
										// TODO wrap the restore in a finally ?
										stackRestore(stack);
										return Session.bind(ref);
									}

									run() {
										Session_run(this.ptr);
									}
									dumpBuffers() {
										Session_dumpBuffers(this.ptr);
									}
									start() {
										lastBuffers = {};
										Session_start(this.ptr, this.lastOp.ptr.asRef());
										Session_getCurrentId(this.ptr, this.lastId.ptr.asRef());
										doUpdateVis(this.lastOp);
										updateBuffers(this.device, this.module);
									}
									async tick(): Promise<number> {
										var ret = Session_tick(this.ptr);
										if (ret == 0) {
											Session_getCurrentId(this.ptr, this.lastId.ptr.asRef());
										}
										doUpdateVis(this.lastOp);
										updateBuffers(this.device, this.module);
										if (ret > 0) {
											clearVis();
										}
										return ret;
									}
									async step(): Promise<number> {
										this.laneMask.clear();
										(await svgEl).querySelectorAll('.lane').forEach((el, i) => {
											// TODO this assumes a linear indexing of lanes, but we've got per-core indexing in talvos
											if (el.classList.contains('selected')) this.laneMask.add(i);
										});
										var ret = Session_step(this.ptr, this.laneMask.asRef(), this.lastOp.asRef());
										if (ret == 0) {
											Session_getCurrentId(this.ptr, this.lastId.ptr.asRef());
										}
										doUpdateVis(this.lastOp);
										updateBuffers(this.device, this.module);
										if (ret > 0) {
											clearVis();
										}
										return ret;
									}
									switch(args: string[]) {
										// TODO why this dance? what does stack save/stack restore do?
										const stack = stackSave();
										Session_switch(this.ptr, ...toCArgs(['switch', ...args]));
										// TODO wrap the restore in a finally ?
										stackRestore(stack);
									}
									print(args: string[]) {
										// TODO why this dance? what does stack save/stack restore do?
										const stack = stackSave();
										Session_print(this.ptr, ...toCArgs(['print', ...args]));
										// TODO wrap the restore in a finally ?
										stackRestore(stack);
									}
									continue() {
										Session_continue(this.ptr, this.lastOp.ptr.asRef());
										doUpdateVis(this.lastOp);
										updateBuffers(this.device, this.module);
									}
									printContext() {
										Session_printContext(this.ptr);
									}
									get currentInsn() {
										let ret = Session_getCurrentInsn(this.ptr);
										// if (ret == 0) throw new ReferenceError('no current instruction');
										if (ret == 0) return undefined;
										return new Talvos$$Instruction(new Ptr(wasmMemory.buffer, ret, Talvos$$Instruction.SIZE));
									}

									fetchShrubbery() {
										var ret = this.arena.alloc(8);
										Session_fetch_shrubbery(this.ptr, ret.asRef());
										return new BitSet(undefined, { data: ret.data });
									}

									['__destroy__']() {
										// TODO use a finalizer pool?
										console.log('Session.destroy...');
										Session__destroy__(this.ptr);
										this.ptr = 0;
										destroy(this.arena);
									}
								}

								return {
									Session,
									// run: function () {
									// 	return Session.bind(instance.ccall('run_wasm', undefined, ['string', 'string'], arguments));
									// },
									// debug: function () {
									// 	return Session.bind(instance.ccall('debug_wasm', undefined, ['string', 'string'], arguments));
									// },
								};
							}
						);

						return {
							Session: pp.then((val) => val.Session),
							// run: pp.then((val) => val.run),
							// debug: pp.then((val) => val.debug),
						};
					})(),
				];
			})(talvos(Module));
			type Session = Awaited<typeof Session>;

			// TODO this probably belongs in some prejs thing over in talvos-land
			// @ts-ignore
			function destroy(self) {
				self['__destroy__']();
			}

			function withTiming(f: Function, start?: PerformanceMeasure) {
				start = start ?? window.performance.mark('talvos');

				return (async () => f())().finally(() => {
					const call = window.performance.measure(start.name, start.name);
					rootEl.querySelector<HTMLOutputElement>('output.timing')!.value = `done in ${call.duration}ms`;
				});
			}

			// TODO refactor into `withTiming` / `withExec` ?
			function captureOutput(f: Function, start?: PerformanceMeasure) {
				stdioEl.value = '';
				errorEl.value = '';
				stdioEl.hidden = false;
				rootEl.querySelector<HTMLOutputElement>('output.timing')!.value = `...`;
				rootEl.querySelectorAll<HTMLButtonElement>('button.exec,textarea').forEach((el) => (el.disabled = true));
				start = start ?? window.performance.mark('talvos');
				return (async () => f())()
					.catch(async (ex) => {
						var message;
						// @ts-ignore TODO `Property 'Exception' does not exist on type 'typeof WebAssembly'.`
						// e.g. ?
						// declare namespace WebAssembly {
						// 	interface Exception {}
						// }
						if (ex instanceof WebAssembly.Exception) {
							var type;
							[type, message] = (await getExceptionMessage)(ex);
							message = message || `of type ${type}`;

							console.error(
								/* must be the only argument to symbolicate properly */
								ex.stack
								/* cf. https://crbug.com/1428532 */
							);

							// this no longer works after https://github.com/emscripten-core/emscripten/pull/21775
							//
							// plus, since we're not doing the save/restore dance properly,
							// it looks like this might not even be enough: https://github.com/emscripten-core/emscripten/issues/21606
							//
							// Module.decrementExceptionRefcount(ex);
						} else {
							console.error(`in ${start.name}:`, ex);
							message = '' + ex;
						}
						errorEl.value = message;
					})
					.finally(() => {
						const call = window.performance.measure(start.name, start.name);
						rootEl.querySelector<HTMLOutputElement>('output.timing')!.value = `done in ${call.duration}ms`;
						rootEl
							.querySelectorAll<HTMLButtonElement>('button.exec,textarea')
							.forEach((el) => el.removeAttribute('disabled'));
						// console.log(`done! took ${call.duration}ms`);
						// console.log('output:\n', outBuf);
					});
			}

			rootEl.querySelector<HTMLButtonElement>('button.validate')!.onclick = async function () {
				const text = (rootEl.querySelector('.module') as { value: string } | null)!.value;

				const start = window.performance.mark('validate_wasm', { detail: { text } });
				const ok = await captureOutput(async () => (await validate_wasm)(text), start);
				rootEl.querySelector<HTMLOutputElement>('output.stdio')!.value += ok ? 'ok!' : 'not ok :(';
			};

			rootEl.querySelector<HTMLButtonElement>('button.assertion')!.onclick = async () => captureOutput(await assertion);
			rootEl.querySelector<HTMLButtonElement>('button.exception')!.onclick = async () => captureOutput(await exception);
			rootEl.querySelector<HTMLButtonElement>('button.shrubbery')!.onclick = async () => {
				const s = (await Session).bind(0xc0ffeecafe);
				try {
					const bs = s.fetchShrubbery();
					console.log(bs);
				} finally {
					destroy(s.arena);
				}
			};

			rootEl.querySelector<HTMLButtonElement>('button.run')!.onclick = async function () {
				const text = (rootEl.querySelector('.module') as { value: string } | null)!.value;

				const start = window.performance.mark('run_wasm', { detail: { text } });
				captureOutput(async () => {
					const session = new (await Session)(text);
					const entryEl = rootEl.querySelector<HTMLSelectElement>('select[name="entry"]')!;
					session.params.EntryName = entryEl.selectedOptions.item(0)?.value ?? 'main';
					try {
						session.run();
						session.dumpBuffers();
					} finally {
						destroy(session);
					}
					// TODO something goes very wrong when `BUFFER output 2 INT32 FILL 0` (memory access exception reporting failure) and then we try to `run` again
					//   ^ bjorks the whole tab
					// TODO (generally, handling "invalid memory access" better?)
					// 		loosely; I think this means throwing away the whole talvos instance and re-creating it?
				}, start);
			};

			rootEl.querySelector<HTMLButtonElement>('button.debug')!.onclick = async function () {
				stdioEl.value = '';
				stdioEl.hidden = true;
				errorEl.value = '';
				rootEl.querySelector<HTMLOutputElement>('output.timing')!.value = `...`;
				rootEl.querySelectorAll<HTMLButtonElement>('button.exec,textarea').forEach((el) => (el.disabled = true));
				const text = (rootEl.querySelector('.module') as { value: string } | null)!.value;

				const start = window.performance.mark('debug', { detail: { text } });
				withTiming(async () => {
					const session = new (await Session)(text);
					// session.params.EntryName = 'vecadd';
					session.params.EntryName = entryEl.selectedOptions.item(0)?.value ?? 'main';

					const debugCtrl = rootEl.querySelector<HTMLElement>('.debugger')!;

					const ev_start = new CustomEvent('event-binding-lol-TODO-start', { detail: { session } });
					const ev_finish = new CustomEvent('event-binding-lol-TODO-finish', { detail: { session } });
					const ev_tick = new CustomEvent('event-binding-lol-TODO-tick', { detail: { session } });
					const ev_step = new CustomEvent('event-binding-lol-TODO-step', { detail: { session } });

					function finish() {
						withTiming(() => {
							debugCtrl.hidden = true;
							// remove references to 1) allow the session to be GC'd, and 2) safety of the dangling pointer
							debugCtrl.querySelectorAll<HTMLButtonElement>('button').forEach((el) => (el.onclick = null));
							rootEl
								.querySelectorAll<HTMLButtonElement>('button.exec,textarea')
								.forEach((el) => el.removeAttribute('disabled'));
							window.dispatchEvent(ev_finish);

							destroy(session);
						}, window.performance.mark('finish'));

						const call = window.performance.measure(start.name, start.name);
						// we need to be scheduled after the (async) bits in `withTiming`
						// this is good and will in no way be broken by anything I do later
						setTimeout(
							() =>
								(rootEl.querySelector<HTMLOutputElement>('output.timing')!.value +=
									` (session lifetime: ${call.duration}ms)`),
							0
						);
					}

					try {
						session.start();
						window.dispatchEvent(ev_start);

						stdioEl.value = `@ {${[...session.lastId]}} (logical)\n`;
						session.printContext();
					} catch (e) {
						finish();
						throw e;
					}

					const FINISHED = 1; // TODO sync with talvos::PipelineExecutor::StepResult

					debugCtrl.querySelector<HTMLButtonElement>('button.tick')!.onclick = async function () {
						stdioEl.value = '';
						errorEl.value = '';
						const start = window.performance.mark('tick', { detail: {} });
						withTiming(async () => {
							try {
								const last = await session.tick();
								window.dispatchEvent(ev_tick);
								if (last == FINISHED) {
									finish();
								}

								// TODO remove (confusing)
								stdioEl.value = `@ {${[...session.lastId]}} (logical)\n`;
								session.printContext();
							} catch (e) {
								finish();
								throw e;
							}
						}, start);
					};
					debugCtrl.querySelector<HTMLButtonElement>('button.step')!.onclick = async function () {
						stdioEl.value = '';
						errorEl.value = '';
						const start = window.performance.mark('step', { detail: {} });
						withTiming(async () => {
							try {
								const last = await session.step();
								window.dispatchEvent(ev_step);
								if (last == FINISHED) {
									finish();
								}

								stdioEl.value = `@ {${[...session.lastId]}} (logical)\n`;
								session.printContext();
							} catch (e) {
								finish();
								throw e;
							}
						}, start);
					};
					debugCtrl.querySelector<HTMLButtonElement>('button.switch')!.onclick = function () {
						const input = prompt('Usage: switch: X [Y [Z]]', 'X [Y [Z]]'); // %15 is `void` in vecadd
						if (input == null) {
							return;
						}
						const args = input.split(/\s+/);
						session.switch(args);
					};
					debugCtrl.querySelector<HTMLButtonElement>('button.print')!.onclick = function () {
						const input = prompt('Usage: print: %<id>', '%15'); // %15 is `void` in vecadd
						if (input == null) {
							return;
						}
						const args = input.split(/\s+/);
						session.print(args);
					};

					debugCtrl.querySelector<HTMLButtonElement>('button.stop')!.onclick = finish;
					debugCtrl.querySelector<HTMLButtonElement>('button.continue')!.onclick = function () {
						stdioEl.value = '';
						errorEl.value = '';
						withTiming(() => {
							try {
								session.continue();
							} finally {
								// TODO breakpoints
								finish();
							}
						});
					};

					debugCtrl.hidden = false;
				}, start);
			};

			const entryEl = rootEl.querySelector<HTMLSelectElement>('select[name="entry"]')!;
			setTimeout(async function updateEntrypoints() {
				// lol redirect
				const oldOut = stdioEl.value,
					oldErr = errorEl.value;
				stdioEl.value = '';
				errorEl.value = '';

				const text = (rootEl.querySelector('.module') as { value: string } | null)!.value;

				const s = new (await Session)(text);
				try {
					console.log([...s.module.EntryPoints].map((ep) => ep.Name.asString()));
					entryEl.innerHTML = [...s.module.EntryPoints].map((ep) => `<option>${ep.Name.asString()}</option>`).join('');
				} finally {
					destroy(s);
				}

				if (stdioEl.value) {
					console.log(stdioEl.value);
				}
				stdioEl.value = oldOut;
				if (errorEl.value) {
					console.error(errorEl.value);
				}
				errorEl.value = oldErr;
				// TODO polling? or onchange notifications?
				// setTimeout(updateEntrypoints, 2000);
			}, 0);
		</script>
		<link rel="stylesheet" type="text/css" media="all" href="/learn-gpgpu/styles/index.css" />
	</head>
	<body>
		<nav>
			<ul>
				<li><a href="/learn-gpgpu/docs">docs/</a></li>
			</ul>
		</nav>
		<div id="talvos" class:list={vis.init == 'v1' ? ['vis-wip'] : []}>
			<div>
				<main>
					<textarea
						class="module"
						autocorrect="off"
						autocomplete="off"
						autocapitalize="off"
						spellcheck="false"
						aria-label="SPIR-V module assembly (spv_text format)"
						wrap="off">{await getContents('talvos', 'fill_idx.spvasm')}</textarea
					>
				</main>
				<aside>
					<section hidden>
						<label
							>ENTRY
							<select name="entry"></select>
						</label>
						<hr />
					</section>
					<!-- <section>
						<textarea
							class="commands_todo_make_js_concatenate_all_the_commands inactive"
							autocorrect="off"
							autocomplete="off"
							autocapitalize="off"
							spellcheck="false"
							aria-label="Talvos commands (informational)"
							disabled
							wrap="off">{tcfChunks[0]}</textarea
						>
					</section> -->
					<output class="stdio"></output>
					<hr />
					<section class="buffers">
						<!-- <figure>
							<figcaption>Buffer</figcaption>
							<ul></ul>
						</figure> -->

						<!-- <textarea
							class="commands"
							style="height: 434px"
							autocorrect="off"
							autocomplete="off"
							autocapitalize="off"
							spellcheck="false"
							aria-label="Talvos commands (tcf format)"
							wrap="off">{tcfChunks[1]}</textarea
						> -->
					</section>
				</aside>
			</div>

			<div class="controls">
				<select id="vis">
					<option value="v0" selected={vis.init == 'v0' ? '' : undefined}
						>v0: control blocks; executor state colors</option
					>
					<option value="v1" selected={vis.init == 'v1' ? '' : undefined}
						>v1 (wip): control "scrubber"; SSA results</option
					>
				</select>

				<button class="validate exec">validate</button>
				<button class="run exec">run</button>
				<button class="debug exec">debug</button>

				<div hidden>
					<button class="exception">exception</button>
					<button class="assertion">assertion</button>
					<button class="shrubbery">shrubbery</button>
				</div>

				<div class="debugger" hidden>
					<button class="tick">tick</button>
					<!-- cf. PipelineExecutor::help -->
					<button class="step">step</button>
					<button class="switch" hidden>switch</button>
					<button class="print" hidden>print</button>
					<button class="continue">continue</button>
					<button class="stop">stop</button>
					<!-- missing: [break, breakpoint, help, quit] -->
				</div>
			</div>

			<!-- TODO
				 can we pull out just this one wodget into a "component"?
				 it'd be nice to write some code for turning `102043253.21231222ms` into a human time
			-->
			<output class="timing" style="display: block;"></output>
			<output class="error" style="display: block; background-color: #fcebeb;"></output>

			<shadow-root class:list={['vis', 'v0', ...(vis.init == 'v0' ? [] : ['hidden'])]}>
				<svg
					xmlns="http://www.w3.org/2000/svg"
					class="vis0"
					data-cores={vis.cores.length}
					data-lanes={vis.cores[0].lanes.count}
				>
					<style>
						g.core :hover,
						g.core :focus {
							filter: drop-shadow(0 0 3px rgb(0 0 0 / 0.4));
						}

						g.core .ctrl {
							fill: chocolate;
						}

						.lane.selected,
						.ctrl:has(~ .lane.selected):not(:has(~ .lane:not(.selected))) {
							filter: url(#inset-shadow);
						}

						.ctrl:has(~ .lane[data-state='not-launched']):not(:has(~ .lane[data-state='not-launched'])) {
							filter: opacity(60%);
						}

						/* .disabled {
						filter: opacity(60%);
					} */

						/*
						TODO these colors are from NVIDIA nsight; but they're also bad?

						cf. "CUDA Debugger Warp Info View" from https://developer.nvidia.com/nsight-visual-studio-edition
						(https://d29g4g2dyqv443.cloudfront.net/sites/default/files/akamai/tools/nsvse/nsvse2020_1/NsVSE_Dbg_WarpInfo_Vw.png)
					*/
						/* TODO: wait, what's `not-launched` vs `inactive`? */
						.lane[data-state='active'] {
							fill: forestgreen;
						}
						.lane[data-state='inactive'] {
							fill: grey;
						}

						.lane[data-state='at-barrier'] {
							fill: lightseagreen;
						}
						.lane[data-state='at-breakpoint'] {
							fill: red;
						}
						.lane[data-state='at-assert'] {
							fill: orange;
						}
						.lane[data-state='at-exception'] {
							fill: darkred;
						}
						.lane[data-state='not-launched'] {
							fill: darkgray;
						}
						.lane[data-state='exited'] {
							fill: lightgray;
						}

						/* svg text {
						visibility: hidden;
					}
					svg:hover text {
						visibility: visible;
					} */

						/*
						NB: doesn't work for two reasons: css-for-svg doesn't support the `content` property or the `::before` pseudo-element

						cf. https://svgwg.org/svg2-draft/styling.html#RequiredProperties
						and https://svgwg.org/svg2-draft/styling.html#RequiredCSSFeatures
					*/
						/* tspan.physical::before {
						content: 'hello';
					} */

						/* lol there's also CSS-only way to do the hover text, if we don't mind the nth-child(n) -> --var:n mapping thing above */
						/* we'd have to break out using `foreignObject`, though */
					</style>

					<!-- <script></script> -->
					<!-- <defs>
					<pattern id="tenthGrid" width="10" height="10" patternUnits="userSpaceOnUse">
						<path d="M 10 0 L 0 0 0 10" fill="none" stroke="silver" stroke-width="0.5"></path>
					</pattern>
					<pattern id="grid" width="100" height="100" patternUnits="userSpaceOnUse">
						<rect width="100" height="100" fill="url(#tenthGrid)"></rect>
						<path d="M 100 0 L 0 0 0 100" fill="none" stroke="gray" stroke-width="1"></path>
					</pattern>
				</defs>
				<rect width="100%" height="100%" fill="url(#grid)"></rect> -->

					<defs>
						<filter id="inset-shadow">
							<!-- lol hates it -->
							<!-- <link
							href="https://css-tricks.com/adding-shadows-to-svg-icons-with-css-and-svg-filters/#aa-using-svg-filters"
							rel="help"
						/> -->
							<!-- Shadow offset -->
							<feOffset dx="0" dy="0"></feOffset>

							<!-- Shadow blur -->
							<feGaussianBlur stdDeviation="6" result="offset-blur"></feGaussianBlur>

							<!-- Invert drop shadow to make an inset shadow -->
							<feComposite operator="out" in="SourceGraphic" in2="offset-blur" result="inverse"></feComposite>

							<!-- Cut color inside shadow -->
							<feFlood flood-color="black" flood-opacity=".95" result="color"></feFlood>
							<feComposite operator="in" in="color" in2="inverse" result="shadow"></feComposite>

							<!-- Placing shadow over element -->
							<feComposite operator="over" in="shadow" in2="SourceGraphic"></feComposite>
						</filter>
					</defs>

					{
						vis.cores.map((core, i) => (
							<g class="core" transform={`translate(0, ${vis.lanes.height * i + vis.lanes.padding.y * i})`}>
								<rect class="ctrl" x={vis.lanes.width / 4} width={vis.lanes.width * 1.5} height={vis.lanes.height} />
								{Array.from({ length: core.lanes.count }).map((_, j) => (
									<rect
										x={(j + 2) * (vis.lanes.width + vis.lanes.padding.x)}
										width={vis.lanes.width}
										height={vis.lanes.height}
										data-phy-coords={`{ ${i}, ${j} }`}
										class="lane"
										data-state="inactive"
									/>
								))}
							</g>
						))
					}

					<!-- could put this above, if we knew how tall an em was (or translated negatively?) -->
					<text y={vis.cores.length * (vis.lanes.height + vis.lanes.padding.y) + vis.lanes.padding.y}>
						<tspan x="0" dy="1em">physical {`{core, SIMT lane}`}:</tspan>
						<tspan class="physical">N/A</tspan>
						<tspan x="0" dy="1.2em">logical {`{workgroup, invocation}`}:</tspan>
						<tspan class="logical">N/A</tspan>
					</text>
				</svg>
			</shadow-root>

			<div class="controls vis v1" class:list={[...(vis.init == 'v1' ? [] : ['hidden'])]} hidden>
				<button class="vis reset">reset</button>
				<button class="vis step0">step (vis)</button>
				<button class="vis step1">step (op)</button>
			</div>
			<shadow-root class:list={['vis', 'v1', ...(vis.init == 'v1' ? [] : ['hidden'])]}>
				{
					// TODO: this gets hoisted up "above" the earlier scripts when built for `dist`
					//
					// this leads to a deadlock between the top-level await (on `customElements.whenDefined`),
					// and the `customElements.define` call, so instead we wrap the whole thing in its own little
					// immediately-invoked async context.
					//
					// see also: https://discord.com/channels/830184174198718474/1263201016212361329/1263201016212361329
				}
				<script>
					interface ShadowRootElement extends Element {
						get connected(): Promise<void>;
					}

					// TODO
					type Session = any;

					declare global {
						interface WindowEventMap {
							'event-binding-lol-TODO-start': CustomEvent<{ session: Session }>;
							'event-binding-lol-TODO-tick': CustomEvent<{ session: Session }>;
							'event-binding-lol-TODO-step': CustomEvent<{ session: Session }>;
						}
					}

					(async () => {
						const ops: { label: string; kind: 'mem' | 'alu'; values: () => Generator<string> }[] = [
							{
								// %2 = OpAccessChain %_ptr_Input_uint32_t %gl_GlobalInvocationID %n
								label: '%2',
								kind: 'alu',
								values: function* () {
									let addr = 0x1000000000000;
									while (true) {
										const r = `0x${addr.toString(16)}`;
										addr += 4;
										yield r;
									}
								},
							},
							{
								// %3 = OpLoad %uint32_t %2 Aligned 4
								label: '%3',
								kind: 'mem',
								values: function* () {
									let last = 0;
									while (true) {
										yield `${last++}`;
									}
								},
							},
							{
								// %4 = OpAccessChain %_ptr_PhysicalStorageBuffer_uint32_t %buf0 %3
								label: '%4',
								kind: 'alu',
								values: function* () {
									// const base = 0x2000000000000;
									let offset = 0;
									while (true) {
										const last = offset;
										offset += 4;
										// yield `0x${last.toString(16)}`;
										yield `0x20..${last.toString(16).padStart(2, '0')}`;
									}
								},
							},
							{
								// OpStore %4 %3 Aligned 4
								label: 'st',
								kind: 'mem',
								values: function* () {
									while (true) {
										yield '✔';
									}
								},
							},
							{
								// OpReturn
								label: 'ret',
								kind: 'alu',
								values: function* () {
									while (true) {
										yield '✔';
									}
								},
							},
						];
						var state: { cur: number; last: 'completed'[]; gen?: Generator<string> };
						function resetState() {
							state = {
								cur: 1,
								// last: ['completed'],
								// gen: (() => {
								// 	const it = ops[1]!.values();
								// 	it.next();
								// 	return it;
								// })(),
								last: [],
								gen: ops[1]!.values(),
							};
						}
						resetState();

						function deriveState(session: Session) {
							const core = session.cores.get(0);
							const insn = core.PC;
							if (!insn) {
								state.cur = ops.length;
								return;
							}
							let tgt;
							if (insn.hasResultType()) tgt = `%${insn.Operands.get(1)}`;
							else if (insn.Opcode == 62) tgt = 'st';
							else if (insn.Opcode == 253) tgt = 'ret';
							else throw new Error(`unknown opcode: ${insn.Opcode}`);

							for (let i = 0; i < ops.length; i++)
								if (ops[i]!.label == tgt) {
									state.cur = i;
									break;
								}

							const n = parseInt(svgEl.dataset.lanes || '');
							switch (ops[state.cur]?.kind) {
								case 'alu':
									// alu ops complete one "vis step" after they're dispatched
									state.last = core.Microtasks.size() ? [] : Array(n).fill('completed');
									break;
								case 'mem':
									// TODO this is insufficient, since eventually we want these to complete in arbitrary order
									// memory operations complete one "vis step" at a time
									state.last = Array(n - core.Microtasks.size()).fill('completed');
									break;
								default:
									throw new Error(`unknown op kind: ${ops[state.cur]?.kind}`);
							}
						}
						function update(ev: CustomEvent<{ session: Session }>) {
							const {
								detail: { session },
							} = ev;
							deriveState(session);
							drawModule();
						}

						const svgEl = await new Promise<SVGElement>(async (resolve, reject) => {
							// TODO we can do better, but...
							await customElements.whenDefined('shadow-root');
							const roots = document.querySelectorAll<ShadowRootElement>('#talvos shadow-root');
							for (const el of roots) {
								const tgt = el.shadowRoot!.querySelector<SVGElement>('svg.vis1');
								if (tgt) {
									resolve(tgt);
									return;
								}
							}
							reject('el not found');
						});

						// TODO: we should hoist state into the DOM and update it instead of react-style re-rendering
						// but:
						//	1. where do we put `gen` (the current state for the value generator)? That's assuming it's even worth keeping
						//	2. for wip purposes, it's convenient to have a thing that knows how to render any state, and oh look I accidentally a react.
						// @ts-expect-error(6133)
						function updateModule() {
							if (state.cur >= ops.length) return;
							if (!state.gen) state.gen = ops[state.cur]!.values();

							const needTextEls = svgEl.querySelectorAll(
								`:nth-child(${state.cur + 1} of :has(g.results)) g.results > .completed:not(:has(title))`
							);
							for (const el of needTextEls) {
								// TODO we really want something like this for a `<text>`, don't we?
								// or maybe for every result to be its own `g` so we can add a child?
								// el.insertAdjacentElement()
								const titleEl = el.appendChild(document.createElementNS('http://www.w3.org/2000/svg', 'title'));
								titleEl.textContent = state.gen.next().value || 'uh oh'; // TODO

								// seems like there's a few problems to solve:
								// 1. how wide does this result need to be now (we lose fixed width)
								//		-> do we need to "re-flow" everything to the right?
								//		-> should we be using SVG for this at all, then, if we're gonna be doing that?
								// 2. where do we put the <text> ? we can center it on the result's center,
								//     as long as we know we'll fit (see above)
								// 3. how do we make the label accessible, without needing to supply an ID for every
								// 		sub-result (or do we just generate one based on the indexes?)
								// 			cf. https://www.scottohara.me/blog/2019/05/22/contextual-images-svgs-and-a11y.html
							}
						}

						const textAreaEl = document.querySelector<HTMLTextAreaElement>('#talvos textarea')!;
						let initialContents: string;

						function drawModule() {
							const lanes = parseInt(svgEl.dataset.lanes || '');
							svgEl.replaceChildren(
								...svgEl.querySelectorAll('style,defs'),
								((el: Node & SVGElement) => {
									el.setAttribute('href', '#step');
									el.setAttribute('width', '60px');
									el.setAttribute('height', '240px');
									el.setAttribute('x', `${(state.cur || 1) * 60}`); // TODO this works b/c clipping
									return el;
								})(document.createElementNS('http://www.w3.org/2000/svg', 'use')),

								...ops.map((op, idx) => {
									// <svg xmlns="http://www.w3.org/2000/svg" ... />
									const opSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
									opSvg.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns', 'http://www.w3.org/2000/svg');

									opSvg.setAttribute('viewBox', '0 0 60 240');
									opSvg.setAttribute('width', '60px');
									opSvg.setAttribute('height', '240px');
									opSvg.setAttribute('x', `${idx * 60}`);

									const opEl = opSvg.appendChild(document.createElementNS('http://www.w3.org/2000/svg', 'circle'));

									opEl.setAttribute('cx', '30');

									opEl.setAttribute('cy', '55');
									opEl.setAttribute('r', '12');

									if (idx <= state.cur) {
										const progressEl = opSvg.appendChild(
											document.createElementNS('http://www.w3.org/2000/svg', 'text')
										);

										progressEl.setAttribute('x', '30');
										progressEl.setAttribute('y', '1ch');
										progressEl.style.fontSize = 'medium';
										progressEl.style.fontFamily = 'monospace';
										progressEl.setAttribute('dominant-baseline', 'middle');
										progressEl.setAttribute('text-anchor', 'middle');
										progressEl.setAttribute('dy', '0 0.4em 0.4em 0.4em 0.4em');

										if (idx < state.cur) progressEl.append('••••');
										else progressEl.append('•'.repeat(state.last.length), '◦'.repeat(lanes - state.last.length));

										progressEl.setAttribute(
											'dx',
											(() => {
												if (idx <= state.cur && op.kind == 'alu') return ['0', ...Array(lanes - 1).fill('-1ch')];
												else if (idx < state.cur && op.kind == 'mem') return ['0', ...Array(lanes - 1).fill('-0.5ch')];
												else if (op.kind == 'mem')
													return [
														'0',
														...Array(state.last.length).fill('-0.5ch'),
														...Array(lanes - state.last.length - 1).fill('-1ch'),
													];
												else throw new Error(`unknown op kind: ${op.kind}`);
											})().join(' ')
										);
									}

									const opLabelEl = opSvg.appendChild(document.createElementNS('http://www.w3.org/2000/svg', 'text'));
									// x="30" y="55" dominant-baseline="middle" text-anchor="middle"
									opLabelEl.setAttribute('x', '30');
									opLabelEl.setAttribute('y', '55');
									opLabelEl.setAttribute('dominant-baseline', 'middle');
									opLabelEl.setAttribute('text-anchor', 'middle');
									opLabelEl.append(op.label);

									const gEl = opSvg.appendChild(document.createElementNS('http://www.w3.org/2000/svg', 'g'));
									gEl.classList.add('results');

									const gen = op.values();
									// <rect width="20" height="20" x="20" y="80 + ..." class="result dispatched completed"></rect>
									for (var i = 0; i < lanes; i++) {
										const resEl = gEl.appendChild(document.createElementNS('http://www.w3.org/2000/svg', 'rect'));
										resEl.setAttribute('x', '20');
										resEl.setAttribute('y', `${80 + 30 * i}`);
										resEl.setAttribute('width', '20');
										resEl.setAttribute('height', '20');
										resEl.classList.add('result');
										if (idx <= state.cur) resEl.classList.add('dispatched');
										if (idx < state.cur || (idx == state.cur && state.last[i] == 'completed')) {
											resEl.classList.add('completed');
											const titleEl = resEl.appendChild(
												document.createElementNS('http://www.w3.org/2000/svg', 'title')
											);
											titleEl.textContent = gen.next().value || 'oh no, generator ran out of values';
											const textEl = gEl.appendChild(document.createElementNS('http://www.w3.org/2000/svg', 'text'));

											textEl.setAttribute('x', '30');
											textEl.setAttribute('y', `${80 + 30 * i + 10}px`);
											textEl.setAttribute('dominant-baseline', 'middle');
											textEl.setAttribute('text-anchor', 'middle');
											textEl.textContent = titleEl.textContent;
										}
									}

									return opSvg;
								})
							);

							const label = ops[state.cur]?.label;

							// It'd be nice if the spirv-tools assembler kept track of which source line(s) it got an
							// instruction from, but it doesn't.
							// TODO stop doing this on every "tick"
							const linenoToIndex: { [_: number]: number } = {};
							initialContents!.split('\n').forEach(
								(() => {
									let cur = 0; // current index
									return (line, lineno) => {
										if (line.includes(`%${cur + 2} =`)) linenoToIndex[lineno] = cur++;
										else if (line.includes('OpStore')) linenoToIndex[lineno] = cur++;
										else if (line.includes('OpReturn')) linenoToIndex[lineno] = cur++;
										else linenoToIndex[lineno] = -1;
									};
								})()
							);
							textAreaEl.textContent = initialContents!
								.split('\n')
								.flatMap((line, lineno) => {
									const idx = linenoToIndex[lineno]!;
									if (idx >= 0 && idx < state.cur) {
										if (ops[idx]!.kind == 'alu') return [' ', '••••', line.slice(5)].join('');
										else if (ops[idx]!.kind == 'mem')
											return [' •', '  •', '   •', [' ', '   •', line.slice(5)].join('')];
									} else if (state.cur >= ops.length) {
										return [line];
									} else if (
										(label == 'ret' && line.includes('OpReturn')) ||
										(label == 'st' && line.includes('OpStore')) ||
										line.includes(`${label} =`)
									) {
										if (ops[state.cur]!.kind == 'alu') {
											return ['>', state.last.length == 0 ? '◦◦◦◦' : '••••', line.slice(5)].join('');
										} else if (ops[state.cur]!.kind == 'mem') {
											return [
												...state.last.map((_, n) => [' '.repeat(n + 1), '•'].join('')),
												['>', ' '.repeat(state.last.length), '◦'.repeat(lanes - state.last.length), line.slice(5)].join(
													''
												),
											];
										} else {
											console.error('unknown kind for op', ops[state.cur]);
										}
									}

									return [line];
								})
								.join('\n');

							// scroll to bottom
							// at some point we might have to go all the way to:
							// https://css-tricks.com/the-cleanest-trick-for-autogrowing-textareas/
							textAreaEl.scrollTo({
								top: textAreaEl.scrollHeight,
								left: 0,
								behavior: 'smooth',
							});
						}

						// TODO: remove these (they won't work any more)
						// document.querySelector('#talvos .controls button.vis.step0')!.addEventListener('click', tick);
						// document.querySelector('#talvos .controls button.vis.step1')!.addEventListener('click', step);
						// const resetEl = document.querySelector('#talvos .controls button.reset')!;
						// resetEl.addEventListener('click', function () {
						// 	resetState();
						// 	drawModule();
						// });

						window.addEventListener('event-binding-lol-TODO-start', function (ev: CustomEvent<{ session: Session }>) {
							resetState();
							initialContents = textAreaEl.textContent!;
							update(ev);

							// scroll to bottom
							textAreaEl.scrollTo({
								top: textAreaEl.scrollHeight,
								left: 0,
								behavior: 'smooth',
							});
						});
						// TODO:
						window.addEventListener('event-binding-lol-TODO-tick', update);
						window.addEventListener('event-binding-lol-TODO-step', update);
						window.addEventListener('event-binding-lol-TODO-finish', function () {
							resetState(); // reset, but don't redraw
							textAreaEl.textContent = initialContents;
						});
					})();
				</script>
				<!-- TODO: viewBox based on size of computation -->
				<svg
					xmlns="http://www.w3.org/2000/svg"
					viewBox="0 0 300 240"
					height="240px"
					class="vis1"
					data-cores="TODO"
					data-lanes="4"
				>
					<style>
						.result {
							fill-opacity: 0;
							stroke: black;
							stroke-width: 1px;

							transform-box: fill-box;
							transform-origin: center;
							/* transform: rotate(45deg); */
						}

						circle {
							fill: white;
							stroke: black;
						}

						rect {
							fill-opacity: 0;
							stroke: black;
						}

						rect.result:not(.dispatched) {
							stroke: none;
							fill: none;
							/* stroke-dasharray: 1px 8px; */
						}

						rect.result.dispatched:not(.completed) {
							stroke-dasharray: 2px;
						}

						text {
							font-size: smaller;
						}
					</style>

					<defs>
						<svg id="step" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 60 240">
							<style>
								rect.core {
									stroke: none;
									fill: chocolate;
									fill-opacity: 100%;
								}

								.vertical.centerline {
									stroke: none;
								}
							</style>
							<defs>
								<symbol id="handle" width="30" height="30" viewBox="0 0 25 30" preserveAspectRatio="none">
									<polygon points="5 0,25 0,25 20,15 30,5 20"></polygon>
								</symbol>
							</defs>

							<use href="#handle" style="fill-opacity: 0; stroke:black;" x="12"></use>
							<rect x="0" y="30" height="200" width="60"></rect>

							<!-- 40x30 at (10 40); centerline: 30 -->
							<rect x="10" y="40" height="30" width="40" class="core"></rect>
						</svg>

						<line x1="30" y1="0" x2="30" y2="100%" stroke="grey" class="vertical centerline"></line>
					</defs>
				</svg>
			</shadow-root>
			<table>
				<caption>Legend</caption>
				<colgroup>
					<col span="2" />
					<col />
				</colgroup>
				<thead>
					<tr>
						<th scope="colgroup" colspan="2">Symbol</th>
						<th scope="col">Description</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td colspan="2"
							><svg height="30" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 3 4">
								<title>orange box</title>
								<rect width="4" height="3" fill="chocolate"></rect>
							</svg></td
						><td
							>Core: an execution unit that has up to 8 associated lanes for executing program code against data. It has
							a physical ID like 0, 1, 2, 3... etc. and each lane associated with it also has a physical id relative the
							the core itself (so there will be as many lane 0s as there are cores). This toy example GPU has one core
							with with four lanes.<span class="footnote">[1]</span></td
						>
					</tr>
					<tr>
						<td>
							<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 60 110" height="60px">
								<title>outlined box with the "flag" on top</title>
								<defs>
									<symbol id="handle" width="30" height="30" viewBox="0 0 25 30" preserveAspectRatio="none">
										<polygon points="5 0,25 0,25 20,15 30,5 20"></polygon>
									</symbol>
								</defs>

								<use href="#handle" style="fill-opacity: 0; stroke:black;" x="12"></use>
								<rect x="0" y="30" height="80" width="60" style="fill-opacity: 0; stroke: black;"></rect>
							</svg>
						</td><td><pre>&gt;</pre> (in textarea)</td><td
							>Program Counter (PC): a pointer into the program text associated with a core that indicates the next
							operation which will progress. For the purposes of our model, each core only has one PC (per program<span
								class="footnote">[2]</span
							>). That choice is more or less what defines the SIMT model of computation: a core will <em>dispatch</em> as
							many operations as it has (active) lanes at the same time, but those operations will <em>complete</em> independently<span
								class="footnote">[3]</span
							> as the computation .
						</td>
					</tr>
					<tr>
						<td colspan="2">Not Pictured</td>
						<td
							>a sense of overall progress against entire logical space (i.e. all {'{group id, work id, ...}'} coordinates);
							this leaves the part of the "work mapping" entirely up to the reader, unless their problem space is sized 1:1
							with a single core.</td
						>
					</tr>
					<tr>
						<td colspan="2"
							><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 26 26" height="30px">
								<circle cx="13" cy="13" r="12" style="fill: white; stroke: black;"></circle>
								<text x="13" y="13" dominant-baseline="middle" text-anchor="middle" style="font-size: smaller;">%x</text
								></svg
							></td
						><td
							>an operation that will produce results with ID %x; these results will have physical {'{core, lane}'} coordinates
							as well as logical {'{group id, work id, ...}'} coordinates.</td
						>
					</tr>
					<tr>
						<td colspan="2">Not Pictured</td>
						<td
							>the "type" of the operation (more specifically: the set of architectural hazards that may delay
							completion relative to dispatch), like "memory" or "not-memory"</td
						>
					</tr>
					<tr>
						<td
							><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 26 26" height="30px">
								<circle cx="13" cy="13" r="12" style="fill: white; stroke: black;"></circle>
								<text x="13" y="13" dominant-baseline="middle" text-anchor="middle" style="font-size: smaller;">st</text
								></svg
							></td
						>
						<td
							><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 26 26" height="30px">
								<circle cx="13" cy="13" r="12" style="fill: white; stroke: black;"></circle>
								<text x="13" y="13" dominant-baseline="middle" text-anchor="middle" style="font-size: smaller;"
									>ret</text
								></svg
							></td
						>
						<td
							>an operation that will not produce directly identified results, such as `OpStore` (which stores to
							memory) or `OpReturn` (which signals the exit of a program <em>invocation</em>).</td
						>
					</tr>
					<tr>
						<td>◦</td><td>
							<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" height="30px">
								<title>dashed outlined box</title>
								<rect
									height="20"
									width="20"
									style="fill-opacity: 0; stroke: black; stroke-width: 1px; stroke-dasharray: 2px;"></rect>
							</svg></td
						><td
							><em>dispatched</em> operation that will produce a single result. The operation "belongs" to a {
								'{core, lane}'
							} pair.
						</td>
					</tr>
					<tr>
						<td>•</td><td>
							<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" height="30px">
								<title>solid outlined box</title>
								<rect height="20" width="20" style="fill-opacity: 0; stroke: black; stroke-width: 1px;"></rect>
							</svg></td
						><td><em>completed</em> operation that has produced a result.</td>
					</tr>
					<tr>
						<td>•• ... <br />(in textarea)</td><td
							><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 10" height="30px"
								><text x="0" y="1ch" dy="0 0.4em" dx="0 -1ch" style="font-size: medium; font-family: monospace;"
									>••</text
								></svg
							>(in SVG vis view)<td>two results that were computed <em>simultaneously</em>.</td>
						</td>
						<tr>
							<td colspan="2"
								><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 10" height="30px"
									><text x="0" y="1ch" dy="0 0.4em" dx="0 -0.5ch" style="font-size: medium; font-family: monospace;"
										>••</text
									></svg
								><td>two results that were computed <em>sequentially</em> (here, one tick apart).</td>
							</td>
							<tr>
								<td colspan="2">Not Pictured</td>
								<td
									>This toy GPU's memory controller that only lets one operation through per tick (per core, probably?)
									but has infinite bandwidth per operation</td
								>
							</tr>
							<tr>
								<td colspan="2">
									<div class="buffers">
										<figure style="margin-left: 0;">
											<figcaption>Buffer 'a' (16 bytes):</figcaption><ol>
												<li>3</li>
												<li>4</li>
												<li data-prev="17">5</li>
												<li data-prev="10">6</li>
											</ol>
										</figure>
									</div>
								</td>
								<td
									>A view into the GPU's memory for the 16 bytes associated with buffer "a" by the `OpBufferTALVOS`
									metadata opcode; formatted as an array of 4 elements (ideally: with the help of the associated SPIR-V
									type; currently: that's just what you get) with each element identified by its index (offset) such as
									`.[1] = ...` which indicates the value of the four bytes at element offset 1 (i.e. four bytes into the
									memory range) interpreted as an unsigned 32-bit integer; here, the element with index 1 has value 4.
									The view also tracks the most-recently held value, and displays that previous value when the memory
									changed in the most recent interaction (either a tick or a step), as seen here in elements 2 and 3.
								</td>
							</tr>
							<tr>
								<td colspan="2">Not Pictured</td>
								<td
									>The type metadata also associated by way of the `OpBufferTALVOS` opcode that indicates the layout of
									each element of a Buffer view</td
								>
							</tr>
							<tr>
								<td colspan="2">Not Pictured</td>
								<td
									>Memory safety, and especially bidirectional impact of parallel scalability on the same (i.e. the `if
									(i &lt; N)` bit in most CUDA examples).</td
								>
							</tr>
							<tr>
								<td colspan="2">Not Pictured</td>
								<td>Tracking uninitialized memory, visualizing incorrect access bounds.</td>
							</tr>
							<tr>
								<td colspan="2">(the whole textarea)</td>
								<td
									>a program in SPIR-V (with Talvos-specific extensions) that will be interpreted by the virtual GPU</td
								>
							</tr>
							<tr>
								<td colspan="2"><pre>%x = OpXyz %1 %2 %bar</pre></td>
								<td
									>A SPIR-V operation (in text form) that will produce result with id %x by `Xyz`ing its arguments %1 %2
									and %bar.</td
								>
							</tr>
							<tr>
								<td colspan="2">Not Pictured</td>
								<td
									>the whole SPIR-V spec<span class="footnote">[4]</span> (plus associated references such as the Vulkan
									API<span class="footnote">[5]</span>) which describe what an OpXyz does, or why it needs to take
									arguments.</td
								>
							</tr>
						</tr>
					</tr>
				</tbody>
				<tfoot>
					<tr
						><td colspan="3" rowspan="0">
							Footnotes
							<ol>
								<li>
									Strictly speaking, the GPU model has four cores with eight lanes each, but the view only currently
									supports a single core with four lanes.
								</li>
								<li>
									The many-live-programs-per-core will come up again in "parallelism" as a way the GPU implements
									something akin to of "hyper-hyperthreading" to hide memory latencies.
								</li>
								<li>
									Compare with the SIMD model found in almost every modern CPU; a SIMT operation may have <em>some</em> of
									its effects visible sooner than others, even if the overall core's pipeline is stalled waiting on a portion
									of the result set. That combined with explicit static memory tiering (as opposed to implicit dynamic cache
									coherence) and with very deep pipelining (not yet in scope for this project) are three key details to keep
									in mind while thinking about adapting problems to fit a GPU computational model.
								</li>
								<li>
									<a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html"
										>https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html</a
									>
								</li>
								<li>
									e.g. <a
										href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/GlobalInvocationId.html"
										>https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/GlobalInvocationId.html</a
									>
								</li>
							</ol>
						</td></tr
					>
				</tfoot>
			</table>
		</div>

		<script>
			const svgEl = document.querySelector<SVGElement>('#talvos svg.vis0')!;

			const phyEl = svgEl.querySelector<SVGTSpanElement>('tspan.physical')!;
			const logEl = svgEl.querySelector<SVGTSpanElement>('tspan.logical')!;

			const laneEls = svgEl.querySelectorAll<SVGElement>('.lane');
			for (const el of laneEls) {
				el.addEventListener('mouseenter', function () {
					phyEl.textContent = this.dataset.phyCoords!;
					logEl.textContent = this.dataset.logCoords ?? 'N/A';
				});
				el.addEventListener('mouseleave', function () {
					phyEl.textContent = 'N/A';
					logEl.textContent = 'N/A';
				});

				el.addEventListener('click', function () {
					if (this.classList.contains('.disabled')) return;

					this.classList.toggle('selected');
				});
			}

			const ctrlEls = svgEl.querySelectorAll<SVGElement>('.ctrl');
			for (const [i, el] of ctrlEls.entries()) {
				el.addEventListener('mouseenter', function () {
					// TODO don't assume lane width
					phyEl.textContent = `{ ${i}, [${i * 8}-${i * 8 + 7}] }`;
				});
				el.addEventListener('mouseleave', function () {
					phyEl.textContent = 'N/A';
				});

				el.addEventListener('click', function () {
					// TODO tease apart "the scheduler decided" vs "the human decided"
					const selectable = !!this.parentNode!.querySelector(
						'.lane[data-state="active"], .lane[data-state="inactive"]'
					);
					if (!selectable) return;

					const hasNoneSelected = !this.parentNode!.querySelector('.lane.selected');
					this.parentNode!.querySelectorAll<SVGElement>('.lane').forEach((laneEl) => {
						laneEl.classList.toggle('selected', hasNoneSelected);
					});
				});
			}
		</script>
	</body>
</html>
