---
import { getEntry } from 'astro:content';

type GetEntryParams = Parameters<typeof getEntry>;
type Collection = GetEntryParams[0];
type Id = GetEntryParams[1];

async function getContents(c: Collection, f: Id) {
	const file = await getEntry(c, f);
	// there's a type-shaped puzzle box here to remove the `!`;
	// right now, `getContents` accepts anything that might be a "raw file",
	// and/or a collection/id pair that might not even exist.
	//
	// There Exists A Way to restrict the type signature to only allow raw file
	// collections / existing IDs within those collections, but I don't know the
	// typescript meta-language well enough to identify an effective approach.
	return file!.data.contents;
}

// nice to have

// TODO: monaco editor
// TODO: lsp integration w/ tree-sitter
---

<html>
	<head>
		<title>gpgpu playground</title>
		<script>
			// TODO
			/// <zreference types="emscripten" />
			import talvos from '../wasm/talvos-wasm';

			const rootEl = document.getElementById('talvos')!;

			const stdioEl =
				rootEl.querySelector<HTMLOutputElement>('output.stdio') || ({} as { value: HTMLOutputElement['value'] });
			const errorEl =
				rootEl.querySelector<HTMLOutputElement>('output.error') || ({} as { value: HTMLOutputElement['value'] });

			var Module = {
				print: function (text: any) {
					stdioEl.value += text + '\n';
				},
				printErr: function (text: any) {
					stdioEl.value += text + '\n';
				},
			} as any; /* TODO: emscripten types */

			addEventListener('error', (event) => {
				errorEl.value = '' + event.message;
			});

			const [validate_wasm, exception, assertion, { run, debug, Session }] = (function (p: Promise<any>) {
				return [
					p.then((instance) => instance.cwrap('validate_wasm', 'boolean', ['string'])),
					p.then((instance) => instance.cwrap('exception', null, [])),
					p.then((instance) => instance.cwrap('assertion', null, [])),
					(() => {
						var pp = p.then(
							({
								wasmExports: {
									Session__create__,
									Session__destroy__,
									Session_run,
									Session_start,
									Session_step,
									Session_switch,
									Session_print,
									Session_continue,
									Session_printContext,
								},

								stackAlloc,
								stackSave,
								stackRestore,
								stringToUTF8OnStack,
								// writeArrayToMemory, // this is only HEAP8?
								HEAP32,
								// HEAP8,

								...instance
							}) => {
								function toCArgs(args: string[]) {
									const cstrs = args.map(stringToUTF8OnStack) as number[];
									const argv = stackAlloc(cstrs.length);
									// writeArrayToMemory(cstrs, argv);
									// HEAP32.set(cstrs, argv);
									// for (int i )
									cstrs.forEach((s, i) => {
										HEAP32[(argv + i * 4) >> 2] = s;
									});

									return [cstrs.length, argv];
								}

								class Session {
									ptr: any;

									// @ts-ignore
									static bind(ptr) {
										let self = Object.create(this.prototype);
										self.ptr = ptr;
										return self;
									}

									constructor() {
										this.ptr = Session__create__();
									}

									run() {
										Session_run(this.ptr);
									}
									start() {
										Session_start(this.ptr);
									}
									step(): number {
										return Session_step(this.ptr);
									}
									switch(args: string[]) {
										// TODO why this dance? what does stack save/stack restore do?
										const stack = stackSave();
										Session_switch(this.ptr, ...toCArgs(['switch', ...args]));
										// TODO wrap the restore in a finally ?
										stackRestore(stack);
									}
									print(args: string[]) {
										// TODO why this dance? what does stack save/stack restore do?
										const stack = stackSave();
										Session_print(this.ptr, ...toCArgs(['print', ...args]));
										// TODO wrap the restore in a finally ?
										stackRestore(stack);
									}
									continue() {
										Session_continue(this.ptr);
									}
									printContext() {
										Session_printContext(this.ptr);
									}

									['__destroy__']() {
										// TODO use a finalizer pool?
										console.log('Session.destroy...');
										Session__destroy__(this.ptr);
										this.ptr = 0;
									}
								}

								return {
									Session,
									run: function () {
										return Session.bind(instance.ccall('run_wasm', undefined, ['string', 'string'], arguments));
									},
									debug: function () {
										return Session.bind(instance.ccall('debug_wasm', undefined, ['string', 'string'], arguments));
									},
								};
							}
						);

						return {
							Session: pp.then((val) => val.Session),
							run: pp.then((val) => val.run),
							debug: pp.then((val) => val.debug),
						};
					})(),
				];
			})(talvos(Module));
			// TODO?
			// type Session = Awaited<typeof Session>;
			type Session = any;

			// TODO this probably belongs in some prejs thing over in talvos-land
			// @ts-ignore
			function destroy(self) {
				self['__destroy__']();
			}

			// TODO refactor into `withTiming` / `withExec` ?
			function captureOutput(f: Function, qstart?: PerformanceMeasure) {
				stdioEl.value = '';
				errorEl.value = '';
				rootEl.querySelector<HTMLOutputElement>('output.timing')!.value = `...`;
				rootEl.querySelectorAll<HTMLButtonElement>('button.exec').forEach((el) => (el.disabled = true));
				// TODO why does `start = start ?? ...` not narrow the type here?
				let start = qstart ?? window.performance.mark('talvos');
				return (async () => f())()
					.catch((ex) => {
						var message;
						// TODO `Property 'Exception' does not exist on type 'typeof WebAssembly'.`
						// @ts-ignore
						if (ex instanceof WebAssembly.Exception) {
							var type;
							[type, message] = Module.getExceptionMessage(ex);
							message = message || `of type ${type}`;

							console.error(
								/* must be the only argument to symbolicate properly */
								ex.stack
								/* cf. https://crbug.com/1428532 */
							);
							Module.decrementExceptionRefcount(ex);
						} else {
							console.error(`in ${start.name}:`, ex);
							message = '' + ex;
						}
						errorEl.value = message;
					})
					.finally(() => {
						const call = window.performance.measure(start.name, start.name);
						rootEl.querySelector<HTMLOutputElement>('output.timing')!.value = `done in ${call.duration}ms`;
						rootEl.querySelectorAll<HTMLButtonElement>('button.exec').forEach((el) => el.removeAttribute('disabled'));
						// console.log(`done! took ${call.duration}ms`);
						// console.log('output:\n', outBuf);
					});
			}

			rootEl.querySelector<HTMLButtonElement>('button.validate')!.onclick = async function () {
				const text = (rootEl.querySelector('.module') as { value: string } | null)!.value;

				const start = window.performance.mark('validate_wasm', { detail: { text } });
				const ok = await captureOutput(async () => (await validate_wasm)(text), start);
				rootEl.querySelector<HTMLOutputElement>('output.stdio')!.value += ok ? 'ok!' : 'not ok :(';
			};

			rootEl.querySelector<HTMLButtonElement>('button.assertion')!.onclick = async () => captureOutput(await assertion);
			rootEl.querySelector<HTMLButtonElement>('button.exception')!.onclick = async () => captureOutput(await exception);

			rootEl.querySelector<HTMLButtonElement>('button.run')!.onclick = async function () {
				const text = (rootEl.querySelector('.module') as { value: string } | null)!.value;
				const commands = (rootEl.querySelector('.commands') as { value: string } | null)!.value;

				const start = window.performance.mark('run_wasm', { detail: { text, commands } });
				captureOutput(async () => {
					// @ts-ignore
					const session = (await run)(text, commands);
					try {
						session.run();
					} finally {
						destroy(session);
					}
					// TODO something goes very wrong when `BUFFER output 2 INT32 FILL 0` (memory access exception reporting failure) and then we try to `run` again
					//   ^ bjorks the whole tab
					// TODO (generally, handling "invalid memory access" better?)
					// 		loosely; I think this means throwing away the whole talvos instance and re-creating it?
				}, start);
			};

			rootEl.querySelector<HTMLButtonElement>('button.debug')!.onclick = async function () {
				stdioEl.value = '';
				errorEl.value = '';
				rootEl.querySelector<HTMLOutputElement>('output.timing')!.value = `...`;
				rootEl.querySelectorAll<HTMLButtonElement>('button.exec').forEach((el) => (el.disabled = true));
				const text = (rootEl.querySelector('.module') as { value: string } | null)!.value;
				const commands = (rootEl.querySelector('.commands') as { value: string } | null)!.value;

				const start = window.performance.mark('debug', { detail: { text, commands } });
				// @ts-ignore
				const session: Session = (await debug)(text, commands);

				const debugCtrl = rootEl.querySelector<HTMLElement>('.debugger')!;

				function finish() {
					debugCtrl.hidden = true;
					// remove references to 1) allow the session to be GC'd, and 2) safety of the dangling pointer
					debugCtrl.querySelectorAll<HTMLButtonElement>('button').forEach((el) => (el.onclick = null));
					rootEl.querySelectorAll<HTMLButtonElement>('button.exec').forEach((el) => el.removeAttribute('disabled'));

					destroy(session);

					const call = window.performance.measure(start.name, start.name);
					rootEl.querySelector<HTMLOutputElement>('output.timing')!.value = `done in ${call.duration}ms`;
				}

				try {
					session.start();

					session.printContext();
				} catch (e) {
					finish();
					throw e;
				}

				const FINISHED = 1; // TODO sync with talvos::PipelineExecutor::StepResult

				debugCtrl.querySelector<HTMLButtonElement>('button.step')!.onclick = function () {
					stdioEl.value = '';
					errorEl.value = '';
					try {
						const last = session.step();
						if (last == FINISHED) {
							finish();
						}

						session.printContext();
					} catch (e) {
						finish();
						throw e;
					}
				};
				debugCtrl.querySelector<HTMLButtonElement>('button.switch')!.onclick = function () {
					const input = prompt('Usage: switch: X [Y [Z]]', 'X [Y [Z]]'); // %15 is `void` in vecadd
					if (input == null) {
						return;
					}
					const args = input.split(/\s+/);
					session.switch(args);
				};
				debugCtrl.querySelector<HTMLButtonElement>('button.print')!.onclick = function () {
					const input = prompt('Usage: print: %<id>', '%15'); // %15 is `void` in vecadd
					if (input == null) {
						return;
					}
					const args = input.split(/\s+/);
					session.print(args);
				};

				debugCtrl.querySelector<HTMLButtonElement>('button.stop')!.onclick = finish;
				debugCtrl.querySelector<HTMLButtonElement>('button.continue')!.onclick = function () {
					stdioEl.value = '';
					errorEl.value = '';
					try {
						session.continue();
					} finally {
						// TODO breakpoints
						finish();
					}
				};

				debugCtrl.hidden = false;
			};
		</script>
    <link rel="stylesheet" type="text/css" media="all" href="/styles/index.css">
	</head>
	<body>
		<div id="talvos">
			<textarea
				class="module"
				autocorrect="off"
				autocomplete="off"
				autocapitalize="off"
				spellcheck="false"
				aria-label="SPIR-V module assembly (spv_text format)"
				wrap="off">{await getContents('talvos', 'vecadd.spvasm')}</textarea
			>
			<textarea
				class="commands"
				autocorrect="off"
				autocomplete="off"
				autocapitalize="off"
				spellcheck="false"
				aria-label="Talvos commands (tcf format)"
				wrap="off">{await getContents('talvos', 'vecadd.tcf')}</textarea
			>

      <div id="controls">
        <button class="validate exec">validate</button>
        <button class="run exec">run</button>
        <button class="debug exec">debug</button>
      </div>

			<div hidden>
				<button class="exception">exception</button>
				<button class="assertion">assertion</button>
			</div>

			<div class="debugger" hidden>
				<!-- cf. PipelineExecutor::help -->
				<button class="step">step</button>
				<button class="switch">switch</button>
				<button class="print">print</button>
				<button class="continue">continue</button>
				<button class="stop">stop</button>
				<!-- missing: [break, breakpoint, help, quit] -->
			</div>

			<!-- TODO can we pull out just this one wodget into a preact component? -->
			<output class="timing" style="display: block;"></output>
			<output class="stdio" style="display: block; background-color: lightgray; white-space: pre;"></output>
			<output class="error" style="display: block; background-color: #fcebeb;"></output>
		</div>
	</body>
</html>
