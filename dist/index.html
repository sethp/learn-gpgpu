<!DOCTYPE html><html> <head><meta charset="utf-8"><title>gpgpu playground</title><link rel="stylesheet" type="text/css" media="all" href="/learn-gpgpu/styles/index.css"><script type="module" src="/learn-gpgpu/_astro/hoisted.DmCmbri_.js"></script>
<script type="module" src="/learn-gpgpu/_astro/page.LS5KDvwX.js"></script></head> <body> <nav> <ul> <li><a href="/learn-gpgpu/docs">docs/</a></li> </ul> </nav> <div id="talvos" class="vis-wip"> <div> <main> <textarea class="module" autocorrect="off" autocomplete="off" autocapitalize="off" spellcheck="false" aria-label="SPIR-V module assembly (spv_text format)" wrap="off">; SPIR-V
; Version: 1.5
OpCapability Kernel
OpCapability BuffersTALVOS
OpCapability ExecTALVOS
OpCapability PhysicalStorageBufferAddresses
OpExtension &quot;SPV_TALVOS_buffers&quot;
OpExtension &quot;SPV_TALVOS_exec&quot;
OpMemoryModel Logical OpenCL

OpEntryPoint Kernel %main_fn &quot;main&quot; %gl_GlobalInvocationID

OpExecutionGlobalSizeTALVOS %main_fn 4 1 1

OpDecorate %gl_GlobalInvocationID BuiltIn GlobalInvocationId
OpDecorate %_arr_uint32_t ArrayStride 4

; types
                              %void_t = OpTypeVoid
                           %void_fn_t = OpTypeFunction %void_t
                            %uint32_t = OpTypeInt 32 0
                            %gbl_id_t = OpTypeVector %uint32_t 3

                            %arr_len = OpConstant %uint32_t 16
                      %_arr_uint32_t = OpTypeArray %uint32_t %arr_len

                %_ptr_Input_gbl_id_t = OpTypePointer Input %gbl_id_t
                %_ptr_Input_uint32_t = OpTypePointer Input %uint32_t

%_ptr_PhysicalStorageBuffer_uint32_t = OpTypePointer PhysicalStorageBuffer %uint32_t
%_arr_PhysicalStorageBuffer_uint32_t = OpTypePointer PhysicalStorageBuffer %_arr_uint32_t


; global arguments &amp; constants
                    %n = OpConstant %uint32_t 0
%gl_GlobalInvocationID = OpVariable %_ptr_Input_gbl_id_t Input
                 %buf0 = OpBufferTALVOS %_arr_PhysicalStorageBuffer_uint32_t PhysicalStorageBuffer 16 &quot;a&quot;

; FILL_IDX entry point
%main_fn = OpFunction %void_t None %void_fn_t
      %1 = OpLabel

        ; let i = globalWorkId[0]
      %2 = OpAccessChain %_ptr_Input_uint32_t %gl_GlobalInvocationID %n
      %3 = OpLoad %uint32_t %2 Aligned 4

        ; a[i] = i
      %4 = OpAccessChain %_ptr_PhysicalStorageBuffer_uint32_t %buf0 %3
           OpStore %4 %3 Aligned 4

           OpReturn
           OpFunctionEnd
</textarea> </main> <aside> <section hidden> <label>ENTRY
<select name="entry"></select> </label> <hr> </section> <!-- <section>
						<textarea
							class="commands_todo_make_js_concatenate_all_the_commands inactive"
							autocorrect="off"
							autocomplete="off"
							autocapitalize="off"
							spellcheck="false"
							aria-label="Talvos commands (informational)"
							disabled
							wrap="off">{tcfChunks[0]}</textarea
						>
					</section> --> <output class="stdio"></output> <hr> <section class="buffers"> <!-- <figure>
							<figcaption>Buffer</figcaption>
							<ul></ul>
						</figure> --> <!-- <textarea
							class="commands"
							style="height: 434px"
							autocorrect="off"
							autocomplete="off"
							autocapitalize="off"
							spellcheck="false"
							aria-label="Talvos commands (tcf format)"
							wrap="off">{tcfChunks[1]}</textarea
						> --> </section> </aside> </div> <div class="controls"> <select id="vis"> <option value="v0">v0: control blocks; executor state colors</option> <option value="v1" selected="">v1 (wip): control "scrubber"; SSA results</option> </select> <button class="validate exec">validate</button> <button class="run exec">run</button> <button class="debug exec">debug</button> <div hidden> <button class="exception">exception</button> <button class="assertion">assertion</button> <button class="shrubbery">shrubbery</button> </div> <div class="debugger" hidden> <button class="tick">tick</button> <!-- cf. PipelineExecutor::help --> <button class="step" disabled>step</button> <!-- step disabled b/c of glitch in vis, see event binding below --> <button class="switch" hidden>switch</button> <button class="print" hidden>print</button> <button class="continue">continue</button> <button class="stop">stop</button> <!-- missing: [break, breakpoint, help, quit] --> </div> </div> <!-- TODO
				 can we pull out just this one wodget into a "component"?
				 it'd be nice to write some code for turning `102043253.21231222ms` into a human time
			--> <output class="timing" style="display: block;"></output> <output class="error" style="display: block; background-color: #fcebeb;"></output> <shadow-root class="vis v0 hidden"> <svg xmlns="http://www.w3.org/2000/svg" class="vis0" data-cores="4" data-lanes="8"> <style>
						g.core :hover,
						g.core :focus {
							filter: drop-shadow(0 0 3px rgb(0 0 0 / 0.4));
						}

						g.core .ctrl {
							fill: chocolate;
						}

						.lane.selected,
						.ctrl:has(~ .lane.selected):not(:has(~ .lane:not(.selected))) {
							filter: url(#inset-shadow);
						}

						.ctrl:has(~ .lane[data-state='not-launched']):not(:has(~ .lane[data-state='not-launched'])) {
							filter: opacity(60%);
						}

						/* .disabled {
						filter: opacity(60%);
					} */

						/*
						TODO these colors are from NVIDIA nsight; but they're also bad?

						cf. "CUDA Debugger Warp Info View" from https://developer.nvidia.com/nsight-visual-studio-edition
						(https://d29g4g2dyqv443.cloudfront.net/sites/default/files/akamai/tools/nsvse/nsvse2020_1/NsVSE_Dbg_WarpInfo_Vw.png)
					*/
						/* TODO: wait, what's `not-launched` vs `inactive`? */
						.lane[data-state='active'] {
							fill: forestgreen;
						}
						.lane[data-state='inactive'] {
							fill: grey;
						}

						.lane[data-state='at-barrier'] {
							fill: lightseagreen;
						}
						.lane[data-state='at-breakpoint'] {
							fill: red;
						}
						.lane[data-state='at-assert'] {
							fill: orange;
						}
						.lane[data-state='at-exception'] {
							fill: darkred;
						}
						.lane[data-state='not-launched'] {
							fill: darkgray;
						}
						.lane[data-state='exited'] {
							fill: lightgray;
						}

						/* svg text {
						visibility: hidden;
					}
					svg:hover text {
						visibility: visible;
					} */

						/*
						NB: doesn't work for two reasons: css-for-svg doesn't support the `content` property or the `::before` pseudo-element

						cf. https://svgwg.org/svg2-draft/styling.html#RequiredProperties
						and https://svgwg.org/svg2-draft/styling.html#RequiredCSSFeatures
					*/
						/* tspan.physical::before {
						content: 'hello';
					} */

						/* lol there's also CSS-only way to do the hover text, if we don't mind the nth-child(n) -> --var:n mapping thing above */
						/* we'd have to break out using `foreignObject`, though */
					</style> <!-- <script></script> --> <!-- <defs>
					<pattern id="tenthGrid" width="10" height="10" patternUnits="userSpaceOnUse">
						<path d="M 10 0 L 0 0 0 10" fill="none" stroke="silver" stroke-width="0.5"></path>
					</pattern>
					<pattern id="grid" width="100" height="100" patternUnits="userSpaceOnUse">
						<rect width="100" height="100" fill="url(#tenthGrid)"></rect>
						<path d="M 100 0 L 0 0 0 100" fill="none" stroke="gray" stroke-width="1"></path>
					</pattern>
				</defs>
				<rect width="100%" height="100%" fill="url(#grid)"></rect> --> <defs> <filter id="inset-shadow"> <!-- lol hates it --> <!-- <link
							href="https://css-tricks.com/adding-shadows-to-svg-icons-with-css-and-svg-filters/#aa-using-svg-filters"
							rel="help"
						/> --> <!-- Shadow offset --> <feOffset dx="0" dy="0"></feOffset> <!-- Shadow blur --> <feGaussianBlur stdDeviation="6" result="offset-blur"></feGaussianBlur> <!-- Invert drop shadow to make an inset shadow --> <feComposite operator="out" in="SourceGraphic" in2="offset-blur" result="inverse"></feComposite> <!-- Cut color inside shadow --> <feFlood flood-color="black" flood-opacity=".95" result="color"></feFlood> <feComposite operator="in" in="color" in2="inverse" result="shadow"></feComposite> <!-- Placing shadow over element --> <feComposite operator="over" in="shadow" in2="SourceGraphic"></feComposite> </filter> </defs> <g class="core" transform="translate(0, 0)"> <rect class="ctrl" x="3.75" width="22.5" height="15"></rect> <rect x="32" width="15" height="15" data-phy-coords="{ 0, 0 }" class="lane" data-state="inactive"></rect><rect x="48" width="15" height="15" data-phy-coords="{ 0, 1 }" class="lane" data-state="inactive"></rect><rect x="64" width="15" height="15" data-phy-coords="{ 0, 2 }" class="lane" data-state="inactive"></rect><rect x="80" width="15" height="15" data-phy-coords="{ 0, 3 }" class="lane" data-state="inactive"></rect><rect x="96" width="15" height="15" data-phy-coords="{ 0, 4 }" class="lane" data-state="inactive"></rect><rect x="112" width="15" height="15" data-phy-coords="{ 0, 5 }" class="lane" data-state="inactive"></rect><rect x="128" width="15" height="15" data-phy-coords="{ 0, 6 }" class="lane" data-state="inactive"></rect><rect x="144" width="15" height="15" data-phy-coords="{ 0, 7 }" class="lane" data-state="inactive"></rect> </g><g class="core" transform="translate(0, 16)"> <rect class="ctrl" x="3.75" width="22.5" height="15"></rect> <rect x="32" width="15" height="15" data-phy-coords="{ 1, 0 }" class="lane" data-state="inactive"></rect><rect x="48" width="15" height="15" data-phy-coords="{ 1, 1 }" class="lane" data-state="inactive"></rect><rect x="64" width="15" height="15" data-phy-coords="{ 1, 2 }" class="lane" data-state="inactive"></rect><rect x="80" width="15" height="15" data-phy-coords="{ 1, 3 }" class="lane" data-state="inactive"></rect><rect x="96" width="15" height="15" data-phy-coords="{ 1, 4 }" class="lane" data-state="inactive"></rect><rect x="112" width="15" height="15" data-phy-coords="{ 1, 5 }" class="lane" data-state="inactive"></rect><rect x="128" width="15" height="15" data-phy-coords="{ 1, 6 }" class="lane" data-state="inactive"></rect><rect x="144" width="15" height="15" data-phy-coords="{ 1, 7 }" class="lane" data-state="inactive"></rect> </g><g class="core" transform="translate(0, 32)"> <rect class="ctrl" x="3.75" width="22.5" height="15"></rect> <rect x="32" width="15" height="15" data-phy-coords="{ 2, 0 }" class="lane" data-state="inactive"></rect><rect x="48" width="15" height="15" data-phy-coords="{ 2, 1 }" class="lane" data-state="inactive"></rect><rect x="64" width="15" height="15" data-phy-coords="{ 2, 2 }" class="lane" data-state="inactive"></rect><rect x="80" width="15" height="15" data-phy-coords="{ 2, 3 }" class="lane" data-state="inactive"></rect><rect x="96" width="15" height="15" data-phy-coords="{ 2, 4 }" class="lane" data-state="inactive"></rect><rect x="112" width="15" height="15" data-phy-coords="{ 2, 5 }" class="lane" data-state="inactive"></rect><rect x="128" width="15" height="15" data-phy-coords="{ 2, 6 }" class="lane" data-state="inactive"></rect><rect x="144" width="15" height="15" data-phy-coords="{ 2, 7 }" class="lane" data-state="inactive"></rect> </g><g class="core" transform="translate(0, 48)"> <rect class="ctrl" x="3.75" width="22.5" height="15"></rect> <rect x="32" width="15" height="15" data-phy-coords="{ 3, 0 }" class="lane" data-state="inactive"></rect><rect x="48" width="15" height="15" data-phy-coords="{ 3, 1 }" class="lane" data-state="inactive"></rect><rect x="64" width="15" height="15" data-phy-coords="{ 3, 2 }" class="lane" data-state="inactive"></rect><rect x="80" width="15" height="15" data-phy-coords="{ 3, 3 }" class="lane" data-state="inactive"></rect><rect x="96" width="15" height="15" data-phy-coords="{ 3, 4 }" class="lane" data-state="inactive"></rect><rect x="112" width="15" height="15" data-phy-coords="{ 3, 5 }" class="lane" data-state="inactive"></rect><rect x="128" width="15" height="15" data-phy-coords="{ 3, 6 }" class="lane" data-state="inactive"></rect><rect x="144" width="15" height="15" data-phy-coords="{ 3, 7 }" class="lane" data-state="inactive"></rect> </g> <!-- could put this above, if we knew how tall an em was (or translated negatively?) --> <text y="65"> <tspan x="0" dy="1em">physical {core, SIMT lane}:</tspan> <tspan class="physical">N/A</tspan> <tspan x="0" dy="1.2em">logical {workgroup, invocation}:</tspan> <tspan class="logical">N/A</tspan> </text> </svg> </shadow-root> <div class="controls vis v1" hidden> <button class="vis reset">reset</button> <button class="vis step0">step (vis)</button> <button class="vis step1">step (op)</button> </div> <shadow-root class="vis v1">   <!-- TODO: viewBox based on size of computation --> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 300 240" height="240px" class="vis1" data-cores="TODO" data-lanes="4"> <style>
						.result {
							fill-opacity: 0;
							stroke: black;
							stroke-width: 1px;

							transform-box: fill-box;
							transform-origin: center;
							/* transform: rotate(45deg); */
						}

						circle {
							fill: white;
							stroke: black;
						}

						rect {
							fill-opacity: 0;
							stroke: black;
						}

						rect.result:not(.dispatched) {
							stroke: none;
							fill: none;
							/* stroke-dasharray: 1px 8px; */
						}

						rect.result.dispatched:not(.completed) {
							stroke-dasharray: 2px;
						}

						text {
							font-size: smaller;
						}
					</style> <defs> <svg id="step" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 60 240"> <style>
								rect.core {
									stroke: none;
									fill: chocolate;
									fill-opacity: 100%;
								}

								.vertical.centerline {
									stroke: none;
								}
							</style> <defs> <symbol id="handle" width="30" height="30" viewBox="0 0 25 30" preserveAspectRatio="none"> <polygon points="5 0,25 0,25 20,15 30,5 20"></polygon> </symbol> </defs> <use href="#handle" style="fill-opacity: 0; stroke:black;" x="12"></use> <rect x="0" y="30" height="200" width="60"></rect> <!-- 40x30 at (10 40); centerline: 30 --> <rect x="10" y="40" height="30" width="40" class="core"></rect> </svg> <line x1="30" y1="0" x2="30" y2="100%" stroke="grey" class="vertical centerline"></line> </defs> </svg> </shadow-root> <table> <caption>Legend</caption> <colgroup> <col span="2"> <col> </colgroup> <thead> <tr> <th scope="colgroup" colspan="2">Symbol</th> <th scope="col">Description</th> </tr> </thead> <tbody> <tr> <td colspan="2"><svg height="30" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 3 4"> <title>orange box</title> <rect width="4" height="3" fill="chocolate"></rect> </svg></td><td>Core: an execution unit that has up to 8 associated lanes for executing program code against data. It has
							a physical ID like 0, 1, 2, 3... etc. and each lane associated with it also has a physical id relative the
							the core itself (so there will be as many lane 0s as there are cores). This toy example GPU has one core
							with with four lanes.<span class="footnote">[1]</span></td> </tr> <tr> <td> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 60 110" height="60px"> <title>outlined box with the "flag" on top</title> <defs> <symbol id="handle" width="30" height="30" viewBox="0 0 25 30" preserveAspectRatio="none"> <polygon points="5 0,25 0,25 20,15 30,5 20"></polygon> </symbol> </defs> <use href="#handle" style="fill-opacity: 0; stroke:black;" x="12"></use> <rect x="0" y="30" height="80" width="60" style="fill-opacity: 0; stroke: black;"></rect> </svg> </td><td><pre>&gt;</pre> (in textarea)</td><td>Program Counter (PC): a pointer into the program text associated with a core that indicates the next
							operation which will progress. For the purposes of our model, each core only has one PC (per program<span class="footnote">[2]</span>). That choice is more or less what defines the SIMT model of computation: a core will <em>dispatch</em> as
							many operations as it has (active) lanes at the same time, but those operations will <em>complete</em> independently<span class="footnote">[3]</span> as the computation .
</td> </tr> <tr> <td colspan="2">Not Pictured</td> <td>a sense of overall progress against entire logical space (i.e. all {group id, work id, ...} coordinates);
							this leaves the part of the "work mapping" entirely up to the reader, unless their problem space is sized 1:1
							with a single core.</td> </tr> <tr> <td colspan="2"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 26 26" height="30px"> <circle cx="13" cy="13" r="12" style="fill: white; stroke: black;"></circle> <text x="13" y="13" dominant-baseline="middle" text-anchor="middle" style="font-size: smaller;">%x</text></svg></td><td>an operation that will produce results with ID %x; these results will have physical {core, lane} coordinates
							as well as logical {group id, work id, ...} coordinates.</td> </tr> <tr> <td colspan="2">Not Pictured</td> <td>the "type" of the operation (more specifically: the set of architectural hazards that may delay
							completion relative to dispatch), like "memory" or "not-memory"</td> </tr> <tr> <td><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 26 26" height="30px"> <circle cx="13" cy="13" r="12" style="fill: white; stroke: black;"></circle> <text x="13" y="13" dominant-baseline="middle" text-anchor="middle" style="font-size: smaller;">st</text></svg></td> <td><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 26 26" height="30px"> <circle cx="13" cy="13" r="12" style="fill: white; stroke: black;"></circle> <text x="13" y="13" dominant-baseline="middle" text-anchor="middle" style="font-size: smaller;">ret</text></svg></td> <td>an operation that will not produce directly identified results, such as `OpStore` (which stores to
							memory) or `OpReturn` (which signals the exit of a program <em>invocation</em>).</td> </tr> <tr> <td>◦</td><td> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" height="30px"> <title>dashed outlined box</title> <rect height="20" width="20" style="fill-opacity: 0; stroke: black; stroke-width: 1px; stroke-dasharray: 2px;"></rect> </svg></td><td><em>dispatched</em> operation that will produce a single result. The operation "belongs" to a {core, lane} pair.
</td> </tr> <tr> <td colspan="2"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" height="30px"> <title>solid outlined box</title> <rect height="20" width="20" style="fill-opacity: 0; stroke: black; stroke-width: 1px;"></rect> </svg></td><td><em>completed</em> operation that has produced a result.</td> </tr> <tr> <td colspan="2">•</td><td>a result that is <em>ready</em> to be produced; i.e. all of its dependencies are available. When enough results
							are ready, the core will execute LANE_WIDTH operations to complete them in parallel.</td> </tr> <tr> <td>•• ... <br>(in textarea)</td><td><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 10" height="30px"><text x="0" y="1ch" dy="0 0.4em" dx="0 -1ch" style="font-size: medium; font-family: monospace;">••</text></svg>(in SVG vis view)</td><td>two results that were computed <em>simultaneously</em>.</td> </tr><tr> <td colspan="2"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 10" height="30px"><text x="0" y="1ch" dy="0 0.4em" dx="0 -0.5ch" style="font-size: medium; font-family: monospace;">••</text></svg></td><td>two results that were computed <em>sequentially</em> (here, one tick apart).</td> </tr><tr> <td colspan="2">Not Pictured</td> <td>This toy GPU's memory controller that only lets one operation through per tick (per core, probably?)
									but has infinite bandwidth per operation</td> </tr> <tr> <td colspan="2"> <div class="buffers"> <figure style="margin-left: 0;"> <figcaption>Buffer 'a' (16 bytes):</figcaption><ol> <li>3</li> <li>4</li> <li data-prev="17">5</li> <li data-prev="10">6</li> </ol> </figure> </div> </td> <td>A view into the GPU's memory for the 16 bytes associated with buffer "a" by the `OpBufferTALVOS`
									metadata opcode; formatted as an array of 4 elements (ideally: with the help of the associated SPIR-V
									type; currently: that's just what you get) with each element identified by its index (offset) such as
									`.[1] = ...` which indicates the value of the four bytes at element offset 1 (i.e. four bytes into the
									memory range) interpreted as an unsigned 32-bit integer; here, the element with index 1 has value 4.
									The view also tracks the most-recently held value, and displays that previous value when the memory
									changed in the most recent interaction (either a tick or a step), as seen here in elements 2 and 3.
</td> </tr> <tr> <td colspan="2">Not Pictured</td> <td>The type metadata also associated by way of the `OpBufferTALVOS` opcode that indicates the layout of
									each element of a Buffer view</td> </tr> <tr> <td colspan="2">Not Pictured</td> <td>Memory safety, and especially bidirectional impact of parallel scalability on the same (i.e. the `if
									(i &lt; N)` bit in most CUDA examples).</td> </tr> <tr> <td colspan="2">Not Pictured</td> <td>Tracking uninitialized memory, visualizing incorrect access bounds.</td> </tr> <tr> <td colspan="2">(the whole textarea)</td> <td>a program in SPIR-V (with Talvos-specific extensions) that will be interpreted by the virtual GPU</td> </tr> <tr> <td colspan="2"><pre>%x = OpXyz %1 %2 %bar</pre></td> <td>A SPIR-V operation (in text form) that will produce result with id %x by `Xyz`ing its arguments %1 %2
									and %bar.</td> </tr> <tr> <td colspan="2">Not Pictured</td> <td>the whole SPIR-V spec<span class="footnote">[4]</span> (plus associated references such as the Vulkan
									API<span class="footnote">[5]</span>) which describe what an OpXyz does, or why it needs to take
									arguments.</td> </tr> </tbody> <tfoot> <tr><td colspan="3" rowspan="0">
Footnotes
<ol> <li>
Strictly speaking, the GPU model has four cores with eight lanes each, but the view only currently
									supports a single core with four lanes.
</li> <li>
The many-live-programs-per-core will come up again in "parallelism" as a way the GPU implements
									something akin to of "hyper-hyperthreading" to hide memory latencies.
</li> <li>
Compare with the SIMD model found in almost every modern CPU; a SIMT operation may have <em>some</em> of
									its effects visible sooner than others, even if the overall core's pipeline is stalled waiting on a portion
									of the result set. That combined with explicit static memory tiering (as opposed to implicit dynamic cache
									coherence) and with very deep pipelining (not yet in scope for this project) are three key details to keep
									in mind while thinking about adapting problems to fit a GPU computational model.
</li> <li> <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html">https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html</a> </li> <li>
e.g. <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/GlobalInvocationId.html">https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/GlobalInvocationId.html</a> </li> </ol> </td></tr> </tfoot> </table> </div>  </body> </html>